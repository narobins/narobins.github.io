<html lang="en">
	<head>
		<title>Color Sandbox</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
		<link rel="manifest" href="icons/site.webmanifest">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
				color: white;
				text-align: center;
				position: relative;
			}
			#outer-container {
				position: absolute;
				width: 100%;
				height: 100%;
			}
			#container {
				position: absolute;
				width: 86vw;
				height: 86vh;
			}
			#inner-container {
				position: relative;
				top: 7vh;
				bottom: 7vh;
				left: 7vw;
				right: 7vw;
			}
			#canvas {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
			}
			#menu {
				display: none;
				opacity: 0.5;
				position: absolute;
				top: 0;
				left: 0;
				margin: 0;
				text-align: left;
				width: 100%;
				height: 100%;
			}
			#menu #menu-container {
				padding: 30px;
				margin: 20px;
				background: black;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				position: absolute;
				overflow-y: scroll;
			}
			@media only screen and (orientation: landscape) {
				#icon-menu {
					width: 30px;
				}
			}
			@media (hover: none) {
				.instructions[data-device="desktop"] {
					display: none !important;
				}
			}
			@media (hover: hover) {
				.instructions[data-device="touchscreen"] {
					display: none !important;
				}
			}
			#icon-menu {
				position: fixed;
				left: 0;
				top: 0;
				padding: 0;
				margin: 5px;
				z-index: 2;
			}
			#icon-menu i {
				width: 30px;
				line-height: 30px;
				height: 30px;
				display: inline-block;
				cursor: pointer;
				opacity: 0.3;
				float: left;
				margin: 5px;
			}
			#icon-menu i.active {
				opacity: 1.0;
			}
			.close {
				position: absolute;
				top: 15px;
				right: 15px;
				cursor: pointer;
			}
			.menu-icons i {
				cursor: pointer;
			}
			.menu-icons a {
				color: white;
			}
			p {
				margin: 5px;
			}
			.fixed-w {
				display: inline-block;
				width: 140px;
			}
			h3, h2 {
				margin-bottom: 0;
			}
			.instructions {
				display: none;
				bottom: 0;
				margin: 0;
				height: 6vh;
				position: absolute;
				opacity: 0.3;
				width: 100%;
			}
			.instructions.active {
				display: block;
			}
		</style>
	</head>
	<body>
		<div id='icon-menu'>
			<a id="toggle-menu" onClick="toggleModal()"><i class="material-icons">help</i></a>
			<a title="shape"><i class="tool-icon material-icons draw-tool active" data-mode="draw">category</i></a>
			<a title="color"><i class="tool-icon material-icons color-tool" data-mode="color">palette</i></a>
			<a title="transform"><i class="tool-icon material-icons transform-tool" data-mode="transform">open_with</i></a>
		</div>

		<div id="outer-container">
		<div id="container">
			<div id="inner-container">
				<canvas id="canvas">Your browser does not support Canvas.</canvas>

				<div id="menu">
					<div id="menu-container">
						<i class="material-icons close" onClick="toggleModal()">close</i>
						<div class="menu-icons">
							<a id="download"><i class="material-icons" alt="save" onClick="saveCanvas()">save</i></a>
						</p>
						<h2>Color Sandbox</h2>

						<p>A fun and quick way to make shapes, choose colors, and play with composition.</p>

						<h2>Why?</h2>
						<p>We have many wonderful tools that can help us make beautiful images. It's hard to make something when you expect it to be beautiful and you also have an undo button. Let's make some mediocre images and congratulate ourselves for choosing creation over mindless internet browsing.</p>


						<h2>Inspiration</h2>
						<ul>
							<li><a href='https://color.hailpixel.com/' target="_blank">this color picker</a>. Minimal interface and instant feedback.</li>
							<li><a href='https://store.steampowered.com/app/953300/ART_SQOOL/' target="_blank">this game</a>. Haven't played it, but I like that it hides "worthwhile" lessons inside weird fun.</li>
							<li><a href='https://www.instagram.com/p/BgSGhCjluxC/' target="_blank">this class</a>. Particularly: all color is relative, think shapes not lines, block in fast and adjust later.</li>
							<li><a href='https://www.heavypoly.com/heavypaint' target="_blank">this app</a>. Fewer options means you're making more important decisions. Also, portability.</li>

						</ul>

						<h2>Technical</h2>
						<p><span id='numShapes'>0</span> shapes, <span id='numVertices'>0</span> vertices</p>
						<p>Made with <a href='http://threejs.org'>three.js</a></p>
						<a href="https://github.com/narobins/narobins.github.io/blob/master/drawtools/colorsandbox.html" target="_blank"><i class="material-icons" alt="code">code</i></a>
						<br />

					</div>
				</div>
			</div>
		</div>
		</div>
		<p class='instructions active' data-device='desktop' data-mode="draw">click or drag to draw shape, double click to close</p>
		<p class='instructions' data-device='desktop' data-mode="color">drag to shift hue, scroll to shift value</p>
		<p class='instructions' data-device='desktop' data-mode="transform">left drag to move, right drag to scale and rotate, scroll to change overlap</p>

		<p class='instructions active' data-device='touchscreen' data-mode="draw">tap or drag to draw shape, double click to close</p>
		<p class='instructions' data-device='touchscreen' data-mode="color">tap to select, drag to shift hue, two finger scroll to shift value</p>
		<p class='instructions' data-device='touchscreen' data-mode="transform">one finger to move, two fingers to scale and rotate</p>

		<script src="https://threejs.org/build/three.js"></script>

		<script src="https://threejs.org/examples/js/WebGL.js"></script>

		<script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
		<script src="https://threejs.org/examples/js/shaders/FXAAShader.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/OutlinePass.js"></script>

		<script id="hueVisualizeVertex" type="x-shader/x-vertex">

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}

		</script>
		<script id="hueVisualizeFragment" type="x-shader/x-fragment">

		varying vec2 vUv;
		const float pi = 3.14159;

		// All components are in the range [0â€¦1], including hue.
		// source: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl
		vec3 hsv2rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}

		void main() {
			gl_FragColor = vec4(1.0);
			vec2 nUv = (vUv.xy - vec2(0.5, 0.5)) * 2.0;
			if (pow(nUv.x, 2.0) + pow(nUv.y, 2.0) < 0.5) {
				discard;
			}
			gl_FragColor.x = (atan(nUv.y, nUv.x)  ) / (2.0 * pi);
			gl_FragColor.xyz = hsv2rgb(gl_FragColor.xyz);
		}

		</script>

		<script>
			// TODO
			// download in new tab?

			// scene
			var container;
			var camera, scene, renderer, composer, outlinePass, effectFXAA ;
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var squareBG;
			var CANVAS_WIDTH;
			var CANVAS_HEIGHT;
			var MODE = 'draw';

			// config / performance settings
			var MAX_POINTS = 500;
			var MAX_ZDEPTH = 1000;
			var PREV_DIST = 80;
			var HUE_SHIFT_SENSITIVITY = 1.0/150.0;
			var EPSILON = 0.0001;
			var VALUE_SHIFT_SENSITIVITY = 0.02;

			// draw
			var p_idx = 0;
			var currentLine = false;
			var prevPt = false;
			var hueShiftColor;
			var newShapePt = false;

			// transform
			var currentTransformPt = false;
			var transformOrigin = false;
			var startScale = false;
			var startRotate = 0;

			// other
			var currentObj = false;
			var lastTapTime = new Date().getTime();
			var lastTapPos = false;
			var latestDrag = false;
			var colorObj = false;
			var zCount = 1;

			var fingers = false;

			var lineViz = false;
			var hueViz = false;

			initDim();

			init();
			animate();

			document.getElementById('download').addEventListener('touchstart', function(event) {
				saveCanvas(event);
			})

			document.getElementById('toggle-menu').addEventListener('touchstart', function(event) {
				toggleModal();
			})

			var toolIcons = document.getElementsByClassName('tool-icon');
			var toolInstructions = document.getElementsByClassName('instructions');
			for (var i = 0; i < toolIcons.length; i++) {
				toolIcons[i].addEventListener('mousedown', switchTool)
			}

			// gui
			///////////////////////////////////////////////////////////////////

			function toggleModal() {
				var menu = document.getElementById("menu");
				if (menu.style.display == "block") {
					menu.style.display = "none";
					MODE = document.getElementsByClassName("active")[0].getAttribute('data-mode');
				} else {
					menu.style.display = "block";
					MODE = '';
				}
			}

			function switchTool(e) {
				e.target.className = "material-icons tool-icon active";
				MODE = e.target.getAttribute('data-mode');
				for (var i = 0; i < toolIcons.length; i++) {
					if (toolIcons[i].getAttribute('data-mode') != MODE) {
						toolIcons[i].className = "material-icons tool-icon";
					}
				}
				for (var i = 0; i < toolInstructions.length; i++) {
					if (toolInstructions[i].getAttribute('data-mode') != MODE) {
						toolInstructions[i].className = "instructions";
					} else {
						toolInstructions[i].className = "instructions active";
					}
				}
				clearCanvas();
				clearDraw();
			}

			// scene
			///////////////////////////////////////////////////////////////////

			function initDim() {
				bb = document.getElementById("canvas").getBoundingClientRect();
				CANVAS_WIDTH = bb.width;
				CANVAS_HEIGHT = bb.height;
			}

			function init() {
				var bb = document.getElementById("canvas").getBoundingClientRect();

				var aspect = bb.width / bb.height;
				var frustum = bb.height;

				// camera
				camera = new THREE.OrthographicCamera(
					frustum * aspect / - 2,
					frustum * aspect / 2,
					frustum / 2,
					frustum / - 2,
					1,
					2 * MAX_ZDEPTH + 1 );
				camera.position.z = MAX_ZDEPTH + 1;

				scene = new THREE.Scene();

				// setup doc
				var squareMesh = new THREE.PlaneGeometry(CANVAS_WIDTH, CANVAS_HEIGHT)
				var startColor = new THREE.Color();
				startColor.setHSL(Math.random(), Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2);
				var squareMaterial = new THREE.MeshBasicMaterial( { color: startColor } );
				squareBG = new THREE.Mesh(squareMesh, squareMaterial);
				squareBG.position.z = -MAX_ZDEPTH + 1;
				scene.add(squareBG);

				// renderer stuff
				canvas = document.getElementById("canvas");
				container = document.getElementById("outer-container");
				renderer = new THREE.WebGLRenderer({canvas: canvas, preserveDrawingBuffer: true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( bb.width, bb.height );
				renderer.sortElements = false;

				// postprocessing
				composer = new THREE.EffectComposer( renderer );
				composer.setSize( bb.width, bb.height );
				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );

				outlinePass = new THREE.OutlinePass( new THREE.Vector2( bb.width, bb.height ), scene, camera );
				outlinePass.edgeStrength = 0.5;
				outlinePass.edgeGlow = 0;
				outlinePass.edgeThickness = 1;
				outlinePass.visibleEdgeColor.set(0xffffff);
				outlinePass.hiddenEdgeColor.set(0x000000);
				composer.addPass( outlinePass );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				effectFXAA.renderToScreen = true;
				composer.addPass( effectFXAA );

				container.addEventListener( "mousedown", onDocumentMouseDown, false );
				container.addEventListener( "touchstart", onDocumentMouseDown, false );
				container.addEventListener( "mousemove", onDocumentMouseMove, false );
				container.addEventListener( "touchmove", onDocumentMouseMove, false );
				container.addEventListener( "mouseup", onDocumentMouseUp, false );
				container.addEventListener( "touchend", onDocumentMouseUp, false );
				container.addEventListener( "wheel", onDocumentMouseWheel, false );

				window.addEventListener( "resize", onDocumentResize, false );
				document.addEventListener("keypress", onKeyPress, false);
			}

			function setCurrent(obj) {
				currentObj = obj;
				outline(obj);
				return currentObj;
			}

			function outline(mesh) {
				if (mesh) {
					outlinePass.selectedObjects = [mesh];
				} else {
					outlinePass.selectedObjects = [];
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				composer.render();
			}

			// Visualizers
			///////////////////////////////////////////////////////////////////

			function showLineModal(vec, c) {
				var hsl = new THREE.Color();
				hsl = c.getHSL(hsl);
				var lineColor = hsl.l < 0.4 ? 0xffffff : 0x000000;
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));

				lineViz = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color: lineColor } ) );
				lineViz.position.z = zCount;
				scene.add(lineViz);
			}

			function setLineModal(vec) {
				lineViz.geometry.vertices[1].x = vec.x;
				lineViz.geometry.vertices[1].y = vec.y;
				lineViz.geometry.verticesNeedUpdate = true;
			}

			function showHueWheel(vec, c) {
				clearHueShift();
				showLineModal(vec, c);

				var circleGeo = new THREE.CircleGeometry( 20, 24 );
				var circleMat = new THREE.ShaderMaterial({
					vertexShader: document.getElementById("hueVisualizeVertex").textContent,
					fragmentShader: document.getElementById("hueVisualizeFragment").textContent,
					depthWrite: false,
					depthTest: false
				});
				hueViz = new THREE.Mesh(circleGeo, circleMat);
				hueViz.position.x = vec.x;
				hueViz.position.y = vec.y;
				scene.add(hueViz);
			}

			// Debugging
			///////////////////////////////////////////////////////////////////

			function debugPt(vec, c) {
				c = c || 0xffffff;
				var geometry = new THREE.CircleGeometry(4, 4);
				var material = new THREE.MeshBasicMaterial({color:c});
				var pt = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({color:c}) );
				pt.position.x = vec.x;
				pt.position.y = vec.y;
				pt.position.z = MAX_ZDEPTH;
				scene.add( pt );
				return pt;
			}

			function debugLine(pt1, pt2, c) {
				var pta = new THREE.Vector3();
				var ptb = new THREE.Vector3();
				pta.copy(pt1);
				ptb.copy(pt2);
				var jitter = 0;
				pta.x += Math.random() * jitter;
				pta.y += Math.random() * jitter;
				ptb.x -= Math.random() * jitter;
				ptb.y -= Math.random() * jitter;

				var geo = new THREE.Geometry();
				geo.vertices.push(pta);
				geo.vertices.push(ptb);

				var line = new THREE.Line( geo, new THREE.LineBasicMaterial( { color: c } ) );
				line.position.z = zCount;
				scene.add( line );
			}

			function debugVec(pt, v) {
				var pt2 = new THREE.Vector3(pt.x + 30 * v.x, pt.y + 30 * v.y);
				return debugLine(pt, pt2, 0x00ffff);
			}

			// Draw
			///////////////////////////////////////////////////////////////////

			function startNewShape(vec) {
				clearDraw();
				newShapePt = debugPt(new THREE.Vector3(vec.x, vec.y), 0xffffff);

				var geometry = new THREE.BufferGeometry();
				var pos = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
				geometry.addAttribute( "position", new THREE.BufferAttribute( pos, 3 ) );
				drawCount = 0; // draw the first 2 points, only
				geometry.setDrawRange( 0, 0 );

				var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } );
				currentLine = new THREE.Line( geometry,  material );
				currentLine.position.z = zCount;
				scene.add( currentLine );
			}

			function addPoint(x, y) {
				if (!currentLine) {
					var vec = new THREE.Vector3(x, y, 0.5);
					startNewShape(vec);
					var intersection = intersectPt(canvasPt({'x': x, 'y': y}));
					if (intersection != undefined) {
						var hsl = new THREE.Color();
						hsl = intersection.material.color.getHSL(hsl);
						if (hsl.l < 0.4) {
							currentLine.material.color.r = 1.0;
							currentLine.material.color.g = 1.0;
							currentLine.material.color.b = 1.0;
						}
					}
				}
				var pos = currentLine.geometry.attributes.position.array;

				pos[p_idx ++] = x;
				pos[p_idx ++] = y;
				pos[p_idx ++] = 0;

				currentLine.geometry.setDrawRange( 0, p_idx / 3 );
				currentLine.geometry.attributes.position.needsUpdate = true;
			}

			function avgSampleColors(pts, c) {
				var sample;
				var avg = new THREE.Color(0,0,0);
				var quarter = Math.floor(Math.max(8, pts.length / 3) / 8);
				var nSamples = 0;

				for (var j = 0; j < pts.length / 3; j+=quarter) {
					var eyedropper = new THREE.Vector3(pts[j * 3] + c.x, pts[j * 3 + 1] + c.y);
					// normalize pt, but don't flip y
					sample = intersectPt(canvasPt(eyedropper, flipY=false));
					if (sample != undefined) {
						nSamples += 1;
						avg.add(sample.material.color);
					}
				}
				if (!nSamples) {
					// no samples taken, probably all around edges
					avg.copy(squareBG.material.color);
					nSamples = 1;
				}
				return avg.multiplyScalar(1.0 / nSamples);
			}

			function closeShape() {
				// turns current line into polygon(s)
				// if the line is self-intersecting, will try to split it into multiple polygons, this has bugs
				if (currentLine) {
					// calculate bounding box to find center
					currentLine.geometry.attributes.position.count = currentLine.geometry.drawRange.count;
					currentLine.geometry.computeBoundingSphere();

					var center = new THREE.Vector3();
					center.copy(currentLine.geometry.boundingSphere.center);

					var p = currentLine.geometry.attributes.position.array;
					var n_pts = p_idx;

					// add first point as last point
					p[ p_idx ++ ] = p[0];
					p[ p_idx ++ ] = p[1];
					p[ p_idx ++ ] = p[2];

					function getPt(i) {
						return new THREE.Vector3(p[i], p[i+1]);
					}

					function countIntersections(start, vec, i) {
						// a point is inside a filled area of the polygon if its
						// corresponding ray has an odd number of intersections
						var s = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT);
						var end = new THREE.Vector3(start.x + s * vec.x, start.y + s * vec.y);
						var j = 0;
						var count = 0;
						while (j < n_pts) {
							var intersect;
							if (ptsIntersect(start, end, getPt(j), getPt(j+3))) {
								count += 1;
							}
							j += 3;
						}
						return count % 2 == 1;
					}

					function chooseDirection(start, intersect, a, b, i) {
						// every intersection has two filled and two unfilled quadrants, chooses
						// the direction such that the path will hug the filled quadrant
						var original = new THREE.Vector2(start.x - intersect.x, start.y - intersect.y).normalize();
						var a_pt = getPt(a);
						var b_pt = getPt(b);
						var a_v = new THREE.Vector2(a_pt.x - intersect.x, a_pt.y - intersect.y).normalize();
						var b_v = new THREE.Vector2(p[b] - intersect.x, p[b + 1] - intersect.y).normalize();
						var a_avg = new THREE.Vector2((original.x + a_v.x) / 2, (original.y + a_v.y) / 2).normalize();
						var b_avg = new THREE.Vector2((original.x + b_v.x) / 2, (original.y + b_v.y) / 2).normalize();

						if (countIntersections(intersect, a_avg, i)) {
							return true;
						} else if (countIntersections(intersect, b_avg, i)) {
							return false;
						} else {
							debugPt(intersect, 0xff0000);
							throw new Error('both cant be clockwise');
						}
					}

					function getIntersection(start, end, i) {
						// returns an intersection of the line from start to end
						// (the intersection closest to the start pt)
						var j = 0;
						var res = undefined;
						var a;
						var b;
						while (j < p_idx - 3) {
							var intersect;
							if (!(i == j || i == j + 3)) {
								intersect = ptsIntersect(start, end, getPt(j), getPt(j+3));
								if (intersect) {
									if (res == undefined || sqdist(start, res) > sqdist(start, intersect)) {
										res = intersect;
										a = j;
										b = j + 3;
									}
								}
							}
							j += 3;
						}
						return {
							'cross': res,
							'a': a,
							'b': b
						};
					}

					var i = 0;
					var queue = [[i, new THREE.Vector2(p[i], p[i+1]), 1, false]];
					var shapes = [];
					var limit = 0;

					function trace(i, p_this, dir, i_intersection) {
						var pts = [];
						var visited = [];

						var i_next = i_intersection ? i : i + dir * 3;
						var p_next = new THREE.Vector2(p[i_next], p[i_next + 1]);

						function addPt(p) {
							pts.push(new THREE.Vector2( p.x - center.x, p.y - center.y ));
						}

						while ((i < n_pts || i_intersection) && limit < 1000) {
							limit += 1;
							addPt(p_this);

							i_next = i_intersection ? i : i + 3 * dir;
							p_next = getPt(i_next);

							if (!i_intersection) {
								if (visited.includes((i % n_pts) / 3)) {
									return pts;
								}
								visited.push((i % n_pts) / 3);
							}

							var r = getIntersection(p_this, p_next, i);
							var cross = r.cross;
							var a = r.a;
							var b = r.b;

							if (cross != undefined) {
								choice = chooseDirection(p_this, cross, a, b, i);
								i = choice ? a : b;
								i_other = choice ? b : a;
								i_intersection = true;
								p_this = cross;

								// dir is positive if we chose the higher index
								dir = (i == Math.max(a, b) || (Math.min(a, b) == 0)) ? 1 : -1;

								// save the other direction for later
								var later = [i_other, getPt(i_other), -dir, true];
								queue.push(later);

							} else {
								p_this = p_next;
								i = i_next;
								i_intersection = false;
							}
						}
						return pts;
					}

					var queueOld = [];

					function beenVisited(v, q) {
						for (var idx; idx < q.length; idx++) {
							if (v[0] === q[idx][0] &&
								v[1].x === q[idx][1].x &&
								v[1].y === q[idx][1].y &&
								v[2] === q[idx][2] &&
								v[3] === q[idx][3]) {
								return true;
							}
						}
						return false;
					}

					var visiting = queue.pop();
					while (visiting != undefined) {
						if (!beenVisited(visiting, queueOld) && !beenVisited(visiting, queue)) {
							var path = trace(visiting[0], visiting[1], visiting[2], visiting[3]);
							if (path.length > 0) {
								shapes.push(new THREE.Shape(path));
							}
							queueOld.push(visiting);
						}
						visiting = queue.pop();
					}

					// clear line before averaging colors so we don't sample the line itself
					clearLine();

					// new shape color is average of sampled colors beneath it
					var geometry = new THREE.ShapeBufferGeometry( shapes );
					var avg = avgSampleColors(geometry.attributes.position.array, center);
					avg.offsetHSL(offsetRandom(0.03, 0.01), offsetRandom(0.05, 0.03), offsetRandom(0.03, 0.06));

					var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: avg } ));
					scene.add(mesh);
					mesh.position.x = center.x;
					mesh.position.y = center.y;
					mesh.position.z = zCount;
					zCount += 0.99;

					numVertices = 0;
					scene.children.map(function(a) {
						if (a.id != squareBG.id && a.geometry.attributes != undefined) {
							numVertices += a.geometry.attributes.position.count;
						}
					});
					document.getElementById('numVertices').textContent = String(numVertices)
					document.getElementById('numShapes').textContent = String(scene.children.length - 1)
				}

				clearDraw();
			}

			// Color
			///////////////////////////////////////////////////////////////////

			function setColorObj(obj, hueWheel=true) {
				// sets obj as current color changing object
				// shows hue wheel if obj is defined
				if (!obj || colorObj.id != obj.id) {
					clearHueShift();
					colorObj = obj;
					setCurrent(colorObj);
				}

				if (colorObj && colorObj.material.color) {
					hueShiftColor = colorObj.material.color.clone();
					if (hueWheel) {
						showHueWheel(currentPt(), hueShiftColor);
					}
				}
				return colorObj;
			}

			function startHueShift(event) {
				clearLine();
				obj = checkIntersection(event);
				setColorObj(obj);
				event.preventDefault();
				event.stopPropagation();
			}

			function shiftHue(event) {
				var vec = currentPt();
				setLineModal(vec);

				var diff = new THREE.Vector2(
					lineViz.geometry.vertices[1].x - lineViz.geometry.vertices[0].x,
					lineViz.geometry.vertices[1].y - lineViz.geometry.vertices[0].y,
				);
				var degrees = Math.atan2(diff.y, diff.x) / (2.0 * Math.PI);
				var amount = Math.min(diff.length() * HUE_SHIFT_SENSITIVITY, 1.0);

				colorObj.material.color.set(hueShiftColor);

				// adjust hue in a copy of the color
				var offsetColor = new THREE.Color();
				colorObj.material.color.getHSL(offsetColor);
				offsetColor.setHSL(degrees, 1.0, offsetColor.l);

				// mix offset color back into original color
				offsetColor.multiplyScalar(amount);
				colorObj.material.color.multiplyScalar(1.0 - amount);
				colorObj.material.color.add(offsetColor);
				event.preventDefault();
			}

			function shiftValue(event) {

				if (event.type != "touchmove") {
					setColorObj(checkIntersection(event), hueWheel=false);
					clearHueShift(removeLine=(event.type != "touchmove"));
					clearLine();
				}

				var delta = mouseDelta(event);
				if (delta && colorObj) {
					var hsl = new THREE.Color();
					hsl = colorObj.material.color.getHSL(hsl);
					// uncomment this to enable scrolling left/right for saturation
					// var deltaS = delta.x ? clamp(hsl.s + delta.x, 0, 1) : hsl.s;
					var deltaS = hsl.s;
					var deltaL = delta.y ? clamp(hsl.l + delta.y, 0, 1) : hsl.l;

					colorObj.material.color.setHSL(hsl.h, deltaS, deltaL);
				}

			}

			// Transform
			///////////////////////////////////////////////////////////////////
			function moveShape(shape, delta) {
				var center = {
					'x': shape.position.x,
					'y': shape.position.y,
				};

				var p = {
					'x': transformOrigin.x + delta.x,
					'y': transformOrigin.y + delta.y,
				};
				shape.applyMatrix(new THREE.Matrix4().makeTranslation(p.x - center.x, p.y - center.y, 0) );
			}

			function flipShapes(event) {
				currentObj = currentObj || checkIntersection(event);
				if (currentObj && currentObj.id != squareBG.id) {
					var delta = mouseDelta(event);
					if (event.type == "touchmove") {
						delta *= -1;
					}
					outline(currentObj);
					currentObj.position.z = currentObj.position.z + (delta.y > 0 ? -1 : 1);
					zCount = Math.max(currentObj.position.z, zCount);
					normalizeZDepths();
				}
			}

			function scaleRotateTransform(event) {
				if (currentObj != undefined) {

					var k = (pinchDist(event) / startScale) / currentObj.scale.x;
					if (!lineViz) {
						showLineModal(currentPt(), currentObj.material.color);
					}
					setLineModal(currentPt());

					var o = pinchAngle(event);
					var c = Math.cos(o - startRotate);
					var s = Math.sin(o - startRotate);
					var p = transformOrigin;

					var m = new THREE.Matrix4();
					m.set(
						k*c, -s*k, 0, k*(-c*p.x + s*p.y) + p.x,
						k*s, k*c, 0, k*(-s*p.x - c*p.y) + p.y,
						0, 0, 1, 0,
						0, 0, 0, 1);
					currentObj.applyMatrix(m);
					startRotate = o;
				}
			}

			function getObjectPos(obj) {
				return {
					'x': obj.position.x,
					'y': obj.position.y
				}
			}

			// Clearing
			///////////////////////////////////////////////////////////////////

			function clearDraw() {
				if (newShapePt) {
					scene.remove(newShapePt);
					newShapePt = false;
					prevPt = false;
				}
			}

			function clearCanvas() {
				if (currentObj) {
					currentObj.geometry.computeBoundingSphere();
				}

				// clear color
				clearHueShift();
				colorObj = false;

				// clear transform
				currentTransformPt = false;
				setCurrent(false);
			}

			function clearHueShift(removeLine=true) {
				if (hueViz) {
					scene.remove(hueViz);
					hueViz = false;
				}
				if (lineViz && removeLine) {
					scene.remove(lineViz);
					lineViz = false;
				}
			}

			function clearLine() {
				if (currentLine) {
					scene.remove(currentLine);
					currentLine = false;
					p_idx = 0;
					return true;
				}
			}

			// Events
			///////////////////////////////////////////////////////////////////
			// disable right click menu
			document.oncontextmenu = function () {
				return false;
			};

			function saveCanvas(event) {
				// var img = document.getElementById("canvas").toDataURL("image/png");
				// console.log(img);
				// var nt = window.open(img, "Image");
				var img = document.getElementById("canvas").toDataURL().replace("image/png", "image/octet-stream");
				alert(img);
				document.getElementById("download").setAttribute("href", img);
				document.getElementById("download").setAttribute("download", String(new Date().getTime()) + ".png");
			}

			function onKeyPress() {
				closeShape();
			}

			function onDocumentMouseDown(event) {
				if (event.type === "touchstart") {
					fingers = event.touches.length;
				}
				if (MODE == 'draw') {
					if (event.type === "mousedown" || event.touches != undefined) {
						if (doubleClick(event)) {
							// double click > close shape, but only for mouse or single finger
							closeShape();

						} else {
							// add point
							var vec = currentPt();
							prevPt = vec;
							addPoint(vec.x, vec.y);
						}
						event.preventDefault();
					}

				} else if (MODE == 'color') {
					if (event.type == 'mousedown' && leftClick(event)) {
						startHueShift(event);

					} else if (event.type == 'touchstart' && fingers == 1) {
						tapDown(event);
					}

					event.preventDefault();

				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected && intersected.id != squareBG.id) {
						currentObj = setCurrent(intersected);
						if (currentObj) {
							currentTransformPt = currentPt();

							if ((event.type == 'mousedown' && !rightClick(event)) ||
								(event.touches && fingers == 1)) {
								transformOrigin = getObjectPos(currentObj);

							} else if ((event.touches && fingers == 2) ||
								(event.type == 'mousedown') && rightClick(event)) {
								startScale = pinchDist(event) / currentObj.scale.x;
								startRotate = pinchAngle(event);
								transformOrigin = currentObj.position;

								showLineModal(pinchCenter(event), currentObj.material.color);
							}
						}
					}
				}
				event.preventDefault();
			}

			function onDocumentMouseMove(event) {
				if (MODE == 'draw') {

					if ((event.type == "mousemove" || fingers == 1)) {
						if (prevPt) {
							var vec = currentPt();
							if (sqdist(vec, prevPt) > PREV_DIST) {
								prevPt = vec;
								addPoint(vec.x, vec.y);
							}
						}
					}

				} else if (MODE == 'color') {

					if (event.type == "touchmove" && fingers == 2) {

						shiftValue(event);

					} else if ((event.type == "mousemove" && event.buttons == 1) ||
							(event.type == "touchmove" && fingers == 1)) {

						shiftHue(event);
					}

				} else if (MODE == 'transform') {
					if (currentObj && currentTransformPt) {
						if (event.type == "touchmove" && fingers == 3) {
							flipShapes(event);

						} else if ((event.type == "touchmove" && fingers == 2) ||
							(event.type == 'mousemove') && rightClick(event)) {

							scaleRotateTransform(event);

						} else {
							var vec = currentPt();
							vec.sub(currentTransformPt)
							moveShape(currentObj, vec);
						}
					} else {
						setCurrent(false);
					}
					event.preventDefault();
				}
				event.preventDefault();
			}

			function onDocumentMouseUp(event) {
				if (MODE == "draw" || MODE == "transform" ||
					(MODE == "color" && event.type == "mouseup")) {
					if (currentObj) {
						currentObj.geometry.computeBoundingSphere();
					}

					// clear draw
					setColorObj(false);

					// clear transform
					currentTransformPt = false;

					setCurrent(false);

				} else if (MODE == "color" && event.type == "touchend") {
					if (tapUp(event)) {
						var intersected = checkIntersection(event);
						if (intersected) {
							setColorObj(setCurrent(intersected));
						} else {
							setColorObj(false);
						}

					} else {
						setLineModal(hueViz.position);
					}
				}

				if (event.type == "mouseup" || event.touches.length == 0) {
					prevPt = false;
					latestDrag = false;
				}
				if (event.type == "touchend") {
					fingers = false;
				}
			}

			function onDocumentMouseWheel(event) {
				if (MODE == "color") {

					shiftValue(event);

				} else if (MODE == "transform") {

					flipShapes(event);
				}

				event.preventDefault();
			}

			function onDocumentResize() {
				var w = document.getElementById("container").offsetWidth;
				var h = document.getElementById("container").offsetHeight;
				if (renderer != undefined) {
					renderer.setSize(w, h);
					composer.setSize(w, h);
				}
			}

			// Position detection
			///////////////////////////////////////////////////////////////////

			function intersectPt(pt) {
				raycaster.setFromCamera( pt, camera );
				var intersects = raycaster.intersectObjects( [ scene ], true );

				if ( intersects.length > 0 ) {
					intersects.sort((a, b) => b.object.position.z - a.object.position.z);
					return intersects[ 0 ].object;
				}
			}

			function canvasPt(v, flipY=true) {
				var bb = document.getElementById("canvas").getBoundingClientRect();
				var flip = flipY ? -1 : 1;
				return new THREE.Vector3(((v.x) / bb.width) * 2,
					(flip * (v.y) / bb.height) * 2,
					0.5 );
			}

			function checkIntersection(event) {
				var mouse = mouseToCanvasPt();
				var obj = intersectPt(mouse);
				return obj;
			}

			function currentPt() {
				var vec = mouseToCanvasPt();
				vec.unproject( camera );
				vec.x = clamp(vec.x, -CANVAS_WIDTH, CANVAS_WIDTH);
				vec.y = clamp(vec.y, -CANVAS_HEIGHT, CANVAS_HEIGHT);
				return vec;
			}

			function mouseToCanvasPt() {
				var vec = new THREE.Vector3();

				if (event.touches != undefined || event.changedTouches != undefined) {
					// average all the touch coordinates
					var touches = Object.values(event.touches.length > 0 ? event.touches : event.changedTouches);

					vec.set(
						touches.reduce((a, b) => ({clientX: a.clientX + b.clientX})).clientX / touches.length,
						touches.reduce((a, b) => ({clientY: a.clientY + b.clientY})).clientY / touches.length,
						0.5);
				} else {
					vec.set(event.clientX, event.clientY, 0.5);
				}

				var bb = document.getElementById("canvas").getBoundingClientRect();
				vec.set(((vec.x - bb.left) / bb.width) * 2 - 1,
					(-(vec.y - bb.top) / bb.height) * 2 + 1,
					0.5 );
				return vec;
			}

			// Transform detection
			///////////////////////////////////////////////////////////////////

			function pinchCenter(event) {
				if (event.touches == undefined) {
					return {x: currentObj.position.x, y: currentObj.position.y};
				} else {
					var bb = document.getElementById("canvas").getBoundingClientRect();
					return {
						x: (event.touches[0].clientY - event.touches[1].clientY) / 2 - CANVAS_WIDTH / 2 - bb.left,
						y: -(event.touches[1].clientX - event.touches[0].clientX) / 2 + CANVAS_HEIGHT / 2 + bb.top
					}
				}
			}

			function pinchDist(event) {
				if (event.touches == undefined) {
					var p1 = currentPt();
					var p2 = {x: currentObj.position.x, y: currentObj.position.y};
					return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
				} else if (event.touches.length == 2) {
					return Math.sqrt(
						Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
						Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
					)
				}
			}

			function pinchAngle(event) {
				var p1, p2;
				if (currentObj && event.touches == undefined) {
					p1 = currentPt();
					p2 = {x: currentObj.position.x, y: currentObj.position.y};
					return Math.atan2((p2.y - p1.y), (p2.x - p1.x));

				} else if (event.touches.length == 2) {
					return Math.atan2(
						(event.touches[0].clientY - event.touches[1].clientY),
						(event.touches[1].clientX - event.touches[0].clientX)
					)
				}
			}

			function mouseDelta(event) {
				if (event.type == "touchmove") {
					// three finger drag
					var pt = mouseToCanvasPt();
					if (latestDrag) {
						var delta = {
							x: (pt.x - latestDrag.x),
							y: (pt.y - latestDrag.y)
						};
						latestDrag = pt;
						return delta;
					} else {
						latestDrag = pt;
						return false;
					}
				} else {
					// mouse
					return {
						x: VALUE_SHIFT_SENSITIVITY * clamp(-event.deltaX, -1, 1),
						y: VALUE_SHIFT_SENSITIVITY * clamp(-event.deltaY, -1, 1)
					};
				}
			}

			// Event processing
			///////////////////////////////////////////////////////////////////

			function rightClick(event) { return ("which" in event) ? event.which == 3 : event.button == 2; }

			function leftClick(event) { return ("which" in event) ? event.which == 1 : event.button == 0; }

			function doubleClick(event) {
				var now = new Date().getTime();
				var since = now - lastTapTime;
				lastTapTime = new Date().getTime();

				return (since < 200 && since > 0 && (event.touches == undefined || event.touches.length == 1));
			}

			function tapDown(event) {
				lastTapPos = currentPt();
				lastTapTime = new Date().getTime();
			}
			function tapUp(event) {
				if (lastTapTime && lastTapPos) {
					var currTap = currentPt();

					var now = new Date().getTime();
					var since = now - lastTapTime;

					var tapDist = sqdist(currTap, lastTapPos);

					lastTapTime = false;
					lastTapPos = false;

					return (since < 200 && since > 0 && (tapDist < 2));
				}
			}

			// Utility
			///////////////////////////////////////////////////////////////////

			function offsetRandom(scale, offset) {
				return (2 * Math.round(Math.random()) - 1) * ((Math.random() * scale) + offset);
			}

			function normalizeZDepths() {
				var sorted = scene.children.map(function(a) {
					return {"id": a.id, "z": a.position.z }
				});
				sorted.sort((a, b) => a.z - b.z);
				var count = 0;
				sorted.map(function(a) {
					if (a.id != squareBG.id) {
						scene.getObjectById(a.id).position.z = count;
						count += 0.99;
					}
				});
			}

			function sqdist(v1, v2) { return (v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2; }

			function clamp(v, a, b) { return Math.min(Math.max(v, a), b); }

			function clockwise(v1, v2) { return !(v1.y * v2.x > v1.x * v2.y); }

			// returns true iff the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
			// source: https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function#15182022
			function intersects(a,b,c,d,p,q,r,s) {
				var det, gamma, lambda;
				det = (c - a) * (s - q) - (r - p) * (d - b);
				if (det === 0) {
					return false;
				} else {
					lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
					gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
					if ((EPSILON < lambda && lambda < (1 - EPSILON)) && (EPSILON < gamma && gamma < (1 - EPSILON))) {
						return new THREE.Vector3(
							a + lambda * (c-a),
							b + lambda * (d-b),
						);
					} else {
						return undefined;
					}
				}
			}

			function ptsIntersect(p, q, r, s) {
				return intersects(p.x, p.y, q.x, q.y, r.x, r.y, s.x, s.y);
			}

		</script>

	</body>
</html>

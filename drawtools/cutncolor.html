<html lang="en">
	<head>
		<title>Shape Color Draw Fun</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
	  rel="stylesheet">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
				color: white;
				text-align: center;
				position: relative;
			}
			#container2 {
				width: 84vw;
				height: 84vw;
				margin: 8vw auto;
				position: relative
			}
			#canvas {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
			}
			#menu {
				display: none;
				opacity: 0.5;
				position: absolute;
				top: 0;
				left: 0;
				margin: 0;
				text-align: left;
				width: 100%;
				height: 100%;
			}
			#menu #menu-container {
				padding: 40px;
				margin: 20px;
				background: black;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				position: absolute;
			}
			#icons {
				position: fixed;
				left: 0;
				bottom: 50px;
				width: 44px;
				height: 44px;
				padding: 0;
				margin: 20px;
			}
			#icons a {
				float: left;
				background: rgba(255, 255, 255, 0.15);
				opacity: 0.7;
				margin: 0;
				padding: 5px;
				width: 60px;
				height: 60px;
				cursor: pointer;
				display: none;
			}
			@media only screen and (orientation: landscape) {
				#icons {
					top: 50%;
					margin-left: 0;
					margin-top: -35px;
					/*height: 150px;*/
				}
				#icons a {
					/*height: 140px;*/
					/*vertical-align: middle;*/
				}
				#icons a i {
					line-height: 55px;
				}
			}
			@media only screen and (orientation: portrait) {
				#icons {
					left: 0;
					right: 0;
					bottom: 0;
					margin-left: auto;
					margin-right: auto;
					/*width: 150px;*/
				}
				#icons a {
					/*width: 140px;*/
				}
			}
			#icons a.active {
				display: inline-block;
			}
			#icons a i {
				font-size: 40pt;
			}
			#toggle-menu {
				position: fixed;
				left: 0;
				top: 0;
				font-size: 18pt;
				cursor: pointer;
				padding: 10px;
			}
			.close {
				position: absolute;
				top: 15px;
				right: 15px;
				cursor: pointer;
			}
			.icons {
				bottom: 30px;
				position: absolute;
			}
			.icons i {
				cursor: pointer;
			}
			.icons a {
				color: white;
			}
			p {
				margin: 5px;
			}
			.fixed {
				display: inline-block;
				width: 140px;
			}
			h3, h2 {
				margin-bottom: 0;
			}
		</style>
	</head>
	<body>
		<a id="toggle-menu" onClick="toggleModal()">?</a>
		<div id="icons">
			<a id="draw-tool" title="move mode" class="active" onClick="transformTool()"><i class="material-icons">open_with</i></a>
			<a id="transform-tool" title="draw mode" onClick="drawTool()"><i class="material-icons">edit</i></a>
		</div>
		<div id="container">
			<div id="container2">
				<canvas id="canvas">Your browser does not support Canvas.</canvas>

				<div id="menu">
					<div id="menu-container">
						<i class="material-icons close" onClick="toggleModal()">close</i>
						<h2>About</h2>
						<p>What if drawing interfaces streamlined design decisions (shape, composition, color) rather than mimicking physical media?</p>
						<h2>Usage</h2>
						<h3>Draw mode</h3>
						<p><span class='fixed'>Left click drag</span>: draw shape</p>
						<p><span class='fixed'>Double click</span>: close shape</p>
						<p><span class='fixed'>Right click drag</span>: shift hue</p>
						<p><span class='fixed'>Vertical scroll</span>: shift value</p>

						<h3>Move mode</h3>
						<p><span class='fixed'>Left click drag</span>: move shape</p>
						<p><span class='fixed'>Vertical scroll</span>: bring shape forward/back</p>

						<h2>Stats</h2>
						<p><span id='numShapes'>0</span> shapes, <span id='numVertices'>0</span> vertices</p>
						<br />
						<p class="icons">
							<a id="download"><i class="material-icons" alt="save" onClick="saveCanvas()">save</i></a>
							<a href="https://github.com/narobins" target="_blank"><i class="material-icons" alt="code">code</i></a>
						</p>
					</div>
				</div>
			</div>
		</div>

		<script src="https://threejs.org/build/three.js"></script>

		<!-- <script src="three.min.js"></script> -->
		<!-- <script src="https://threejs.org/build/three.js"></script> -->
		<script src="https://threejs.org/examples/js/WebGL.js"></script>

		<script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
		<script src="https://threejs.org/examples/js/shaders/FXAAShader.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/OutlinePass.js"></script>

		<script id="hueVisualizeVertex" type="x-shader/x-vertex">

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}

		</script>
		<script id="hueVisualizeFragment" type="x-shader/x-fragment">

		varying vec2 vUv;
		const float pi = 3.14159;

		// All components are in the range [0â€¦1], including hue.
		// this function from stackoverflow
		vec3 hsv2rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}

		void main() {
			gl_FragColor = vec4(1.0);
			vec2 nUv = (vUv.xy - vec2(0.5, 0.5)) * 2.0;
			if (pow(nUv.x, 2.0) + pow(nUv.y, 2.0) < 0.5) {
				discard;
			}
			gl_FragColor.x = (atan(nUv.y, nUv.x)  ) / (2.0 * pi);
			gl_FragColor.xyz = hsv2rgb(gl_FragColor.xyz);
		}

		</script>

		<script>
			console.log('hello');

			// TODO
			// download in new tab?
			//
			// tablet
			// three finger drag, edit mode, switches current shape when you leave shape, also imprecise
			// line for three finger drag edit mode

			var container;
			var camera, scene, renderer, composer, outlinePass, effectFXAA ;
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();

			var MAX_POINTS = 500;
			var PREV_DIST = 80;
			var CANVAS_WIDTH;
			var CANVAS_HEIGHT;
			var START_COLOR = new THREE.Color();
			START_COLOR.setHSL(Math.random(), Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2);
			var HUE_SHIFT_SENSITIVITY = 1.0/150.0;
			var MODE = 'draw';

			// draw
			var pos_idx = 0;
			var currentLine = false;
			var prevPt = false;
			var hueShiftColor;
			var squareBG;

			// transform
			var currentTransformPt = false;
			var transformOrigin = false;
			var startScale = false;
			var startRotate = 0;
			var currentObj = false;

			var latestTap = new Date().getTime();
			var latestDrag = false;
			var hoverObj = false;

			var lineVisualizer = false;
			var hueVisualizer = false;

			var zCount = 1;
			var MAX_ZDEPTH = 1000;

			var nPts = 0;

			var lastScale = 1;

			onDocumentResize();

			initDim();

			init();
			animate();

			function toggleModal() {
				var menu = document.getElementById("menu");
				if (menu.style.display !== "none") {
					menu.style.display = "none";
				}
				else {
					menu.style.display = "block";
				}
			}

			function drawTool() {
				document.getElementById("draw-tool").className = "active";
				document.getElementById("transform-tool").className = "";
				document.getElementById("toggle-menu").className = "";
				MODE = 'draw';
				document.body.style.cursor = 'crosshair';
			}

			function transformTool() {
				document.getElementById("draw-tool").className = "";
				document.getElementById("transform-tool").className = "active";
				document.getElementById("toggle-menu").className = "";
				MODE = 'transform';
				document.body.style.cursor = 'move';
			}

			function initDim() {
				bb = document.getElementById("canvas").getBoundingClientRect();
				CANVAS_WIDTH = bb.width;
				CANVAS_HEIGHT = bb.height;
			}

			function init() {
				container = document.getElementById( "container" );
				var bb = document.getElementById("canvas").getBoundingClientRect();

				var aspect = bb.width / bb.height;
				var frustumSize = bb.height;

				// camera
				camera = new THREE.OrthographicCamera(
					frustumSize * aspect / - 2,
					frustumSize * aspect / 2,
					frustumSize / 2,
					frustumSize / - 2,
					1,
					2 * MAX_ZDEPTH + 1 );
				camera.rotation.x = 0;
				camera.rotation.y = 0;
				camera.rotation.z = 0;
				camera.position.x = 0;
				camera.position.y = 0;
				camera.position.z = MAX_ZDEPTH + 1;

				scene = new THREE.Scene();

				// setup doc
				var squareMesh = new THREE.PlaneGeometry(CANVAS_WIDTH, CANVAS_HEIGHT)
				var squareMaterial = new THREE.MeshBasicMaterial( { color: START_COLOR } );
				squareBG = new THREE.Mesh(squareMesh, squareMaterial);
				squareBG.position.z = -MAX_ZDEPTH + 1;
				scene.add(squareBG);

				// renderer stuff
				canvas = document.getElementById("canvas");
				container = document.getElementById("container");
				renderer = new THREE.WebGLRenderer({canvas: canvas, preserveDrawingBuffer: true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( bb.width, bb.height );
				renderer.sortElements = false;

				// postprocessing
				composer = new THREE.EffectComposer( renderer );
				composer.setSize( bb.width, bb.height );
				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );
				// renderPass.renderToScreen = true;

				outlinePass = new THREE.OutlinePass( new THREE.Vector2( bb.width, bb.height ), scene, camera );
				outlinePass.edgeStrength = 0.5;
				outlinePass.edgeGlow = 0;
				outlinePass.edgeThickness = 1;
				outlinePass.visibleEdgeColor.set(0xffffff);
				outlinePass.hiddenEdgeColor.set(0x000000);
				composer.addPass( outlinePass );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				effectFXAA.renderToScreen = true;
				composer.addPass( effectFXAA );

				container.addEventListener( "mousedown", onDocumentMouseDown, false );
				container.addEventListener( "touchstart", onDocumentMouseDown, false );

				container.addEventListener( "mousemove", onDocumentMouseMove, false );
				container.addEventListener( "touchmove", onDocumentMouseMove, false );

				container.addEventListener( "mouseup", onDocumentMouseUp, false );
				container.addEventListener( "touchend", onDocumentMouseUp, false );

				container.addEventListener( "wheel", onDocumentMouseWheel, false );

				window.addEventListener( "resize", onDocumentResize, false );

				document.addEventListener("keypress", onKeyPress, false);
			}

			function checkIntersection(event) {
				var mouse = mouseToCanvasPt();
				var obj = intersectPt(mouse);
				// if (obj.id != squareBG.id) {
					// console.log(obj);
					// outlinePass.selectedObjects = [obj];
				// }
				return obj;
			}

			function startNewShape() {
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
				geometry.addAttribute( "position", new THREE.BufferAttribute( positions, 3 ) );
				drawCount = 0; // draw the first 2 points, only
				geometry.setDrawRange( 0, 0 );

				var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } );
				currentLine = new THREE.Line( geometry,  material );
				currentLine.position.z = zCount;
				scene.add( currentLine );
			}

			function setCurrent(obj) {
				currentObj = obj;
				outline(obj);
				return currentObj;
			}

			function outline(mesh) {
				if (mesh) {
					outlinePass.selectedObjects = [mesh];
				} else {
					outlinePass.selectedObjects = [];
				}
			}

			function addPoint(x, y) {
				if (!currentLine) {
					startNewShape();
					var vec = new THREE.Vector3(x, y, 0.5);
					var intersects = intersectPt(canvasPt({'x': x, 'y': y}));
					if (intersects != undefined) {
						var hsl = new THREE.Color();
						hsl = intersects.material.color.getHSL(hsl);
						if (hsl.l < 0.4) {
							currentLine.material.color.r = 1.0;
							currentLine.material.color.g = 1.0;
							currentLine.material.color.b = 1.0;
						}
					}
				}
				var positions = currentLine.geometry.attributes.position.array;

				positions[ pos_idx ++ ] = x;
				positions[ pos_idx ++ ] = y;
				positions[ pos_idx ++ ] = 0;

				currentLine.geometry.setDrawRange( 0, pos_idx / 3 );
				currentLine.geometry.attributes.position.needsUpdate = true;
			}

			function avgSampleColors(pts) {
				var sample;
				var avg = new THREE.Color(0,0,0);
				var quarter = Math.floor(Math.max(8, pts.length) / 8);
				var nSamples = 0;

				for (var j = 0; j < pts.length; j+=quarter) {
					// normalize pt, but don't flip y
					sample = intersectPt(canvasPt(pts[j], flipY=false));
					if (sample != undefined) {
						nSamples += 1;
						avg.add(sample.material.color);
					}
				}
				if (!nSamples) {
					// no samples taken, probably all around edges
					avg.copy(squareBG.material.color);
					nSamples = 1;
				}
				return avg.multiplyScalar(1.0 / nSamples);
			}

			function offsetRandom(scale, offset) {
				return (2 * Math.round(Math.random()) - 1) * ((Math.random() * scale) + offset);
			}

			function closeShape() {
				console.log('close');
				currentLine.geometry.computeBoundingSphere();
				var center = new THREE.Vector3();
				center.copy(currentLine.geometry.boundingSphere.center);

				console.log(currentLine);
				if (currentLine) {
					var positions = currentLine.geometry.attributes.position.array;
					positions[ pos_idx ++ ] = positions[0];
					positions[ pos_idx ++ ] = positions[1];
					positions[ pos_idx ++ ] = positions[2];

					// make closed shape from line pts
					var pts = [];
					for (var i = 0; i < pos_idx; i+=3) {
						pts.push(new THREE.Vector2( positions[i] - center.x, positions[i+1] - center.y ));
					}

					var avg = avgSampleColors(pts);
					avg.offsetHSL(offsetRandom(0.03, 0.01), offsetRandom(0.05, 0.03), offsetRandom(0.03, 0.06));

					var shape = new THREE.Shape(pts);
					var geometry = new THREE.ShapeBufferGeometry( shape );
					var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: avg } ) );
					scene.add(mesh);
					mesh.position.x = center.x;
					mesh.position.y = center.y;
					mesh.position.z = zCount;
					zCount += 0.99;
					clearLine();

					numVertices = 0;
					scene.children.map(function(a) {
						if (a.id != squareBG.id && a.geometry.attributes != undefined) {
							numVertices += a.geometry.attributes.position.count;
						}
					});
					document.getElementById('numVertices').textContent = String(numVertices)
					document.getElementById('numShapes').textContent = String(scene.children.length - 1)
				}
			}

			function debugPt(vec, c) {
				var geometry = new THREE.CircleGeometry( 8, 4 );
				var material = new THREE.MeshBasicMaterial({color:c});
				var pt = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({color:c}) );
				pt.position.x = vec.x;
				pt.position.y = vec.y;
				pt.position.z = MAX_ZDEPTH;
				// console.log(pt.position);
				scene.add( pt );
			}

			function visualizeLine(vec) {
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));

				lineVisualizer = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
				lineVisualizer.position.z = zCount;
				scene.add( lineVisualizer );
			}

			function visualizeHue(vec) {
				visualizeLine(vec);

				var circleGeo = new THREE.CircleGeometry( 20, 24 );
				var circleMat = new THREE.ShaderMaterial({
					vertexShader: document.getElementById("hueVisualizeVertex").textContent,
					fragmentShader: document.getElementById("hueVisualizeFragment").textContent,
					depthWrite: false,
					depthTest: false
				});
				hueVisualizer = new THREE.Mesh( circleGeo, circleMat );
				hueVisualizer.position.x = vec.x;
				hueVisualizer.position.y = vec.y;
				scene.add( hueVisualizer );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				// renderer.render( scene, camera );
				composer.render();
			}

			// Transform
			///////////////////////////////////////////////////////////////////
			function moveShape(shape, delta) {
				// var center = shape.geometry.boundingSphere.center;

				var center = {
					'x': shape.position.x,
					'y': shape.position.y,
				};

				var p = {
					'x': transformOrigin.x + delta.x,
					'y': transformOrigin.y + delta.y,
				};
				// shape.geometry.translate(p.x - center.x, p.y - center.y, 0);
				// console.log(p);
				// console.log(center);
				shape.applyMatrix(new THREE.Matrix4().makeTranslation(p.x - center.x, p.y - center.y, 0) );
				// shape.geometry.computeBoundingSphere();
				// console.log(center);
				// console.log(shape.position);
			}
			// Events
			///////////////////////////////////////////////////////////////////
			// disable right click menu
			document.oncontextmenu = function () {
				return false;
			};

			function saveCanvas() {
				var img = document.getElementById("canvas").toDataURL().replace("image/png", "image/octet-stream");
				document.getElementById("download").setAttribute("href", img);
				document.getElementById("download").setAttribute("download", "asdf.png");

			}

			function onKeyPress() {
				closeShape();
			}

			function startHueShift(event) {
				clearLine();
				try {
					hoverObj = checkIntersection(event);
					if (hoverObj && hoverObj.material.color) {
						hueShiftColor = hoverObj.material.color.clone();
						visualizeHue(currentPt());
						event.preventDefault();
						event.stopPropagation();
					}
				} catch (err) {
					console.log(err);
				}
			}

			function onDocumentMouseDown(event) {
				if (MODE == 'draw') {
					debugEvent(event);
					if (event.type === "mousedown" || event.touches !== undefined) {

						var now = new Date().getTime();
						var since = now - latestTap;
						latestTap = new Date().getTime();

						if ((since < 200) && since > 0) {
							if (event.touches == undefined || event.touches.length == 1) {
								// double click > close shape, but only for mouse or single finger
								closeShape();
							}

						} else if (rightClick(event) || event.type == "touchstart" && event.touches.length == 2) {
							// right click or double finger drag > shift hue
							startHueShift(event);

						} else {
							// add point
							var vec = currentPt();
							prevPt = vec;
							addPoint(vec.x, vec.y);
						}
						event.preventDefault();
					}
				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected.id != squareBG.id) {
						currentObj = setCurrent(intersected);
						currentTransformPt = currentPt();

						if ((event.type == 'mousedown' && !rightClick(event)) ||
							(event.touches && event.touches.length == 1)) {
							transformOrigin = getObjectPos(currentObj);

						} else if ((event.touches && event.touches.length == 2) ||
							(event.type == 'mousedown') && rightClick(event)) {
							startScale = pinchDist(event) / currentObj.scale.x;
							startRotate = pinchAngle(event);
							if (event.type == 'mousedown') {
								transformOrigin = currentObj.position;
							}
							// debugPt(transformOrigin, new THREE.Vector3(0,0,1));
						}
					}
				}
				event.preventDefault();
			}

			function getObjectPos(obj) {
				// return obj.geometry.boundingSphere.center;
				return {
					'x': obj.position.x,
					'y': obj.position.y
				}
			}

			function flipShapes(event) {
				if (!currentObj) {
					currentObj = checkIntersection(event);
					if (currentObj.id != squareBG.id) {
						var delta = mouseDelta(event);
						outline(currentObj);
						currentObj.position.z = currentObj.position.z + (delta.y > 0 ? -1 : 1);
						zCount = Math.max(currentObj.position.z, zCount);
						normalizeZDepths();
					}
				}
			}

			function onDocumentMouseMove(event) {
				if (MODE == 'draw') {
					debugEvent(event);

					if (event.type == "touchmove" && event.touches.length == 3) {
						prevPt = false;

						if (!hoverObj) {
							hoverObj = checkIntersection(event);
						}
						if (!lineVisualizer) {
							visualizeLine(currentPt());
						}

						onDocumentMouseWheel(event);

						var vec = currentPt();
						lineVisualizer.geometry.vertices[1].x = vec.x;
						lineVisualizer.geometry.vertices[1].y = vec.y;
						lineVisualizer.geometry.verticesNeedUpdate = true;

					} else if ((rightClick(event) ||
							(event.type == "touchmove" && event.touches.length == 2))) {

						if (!hoverObj || !lineVisualizer) {
							startHueShift();
						}

						clearLine();
						prevPt = false;
						var vec = currentPt();
						// vec.z = 0;
						lineVisualizer.geometry.vertices[1].x = vec.x;
						lineVisualizer.geometry.vertices[1].y = vec.y;
						lineVisualizer.geometry.verticesNeedUpdate = true;

						var diff = new THREE.Vector2(
							lineVisualizer.geometry.vertices[1].x - lineVisualizer.geometry.vertices[0].x,
							lineVisualizer.geometry.vertices[1].y - lineVisualizer.geometry.vertices[0].y,
						);
						var degrees = Math.atan2(diff.y, diff.x) / (2.0 * Math.PI);
						var amount = Math.min(diff.length() * HUE_SHIFT_SENSITIVITY, 1.0);

						hoverObj.material.color.set(hueShiftColor);

						// adjust hue in a copy of the color
						var offsetColor = new THREE.Color();
						hoverObj.material.color.getHSL(offsetColor);
						offsetColor.setHSL(degrees, 1.0, offsetColor.l);

						// mix offset color back into original color
						offsetColor.multiplyScalar(amount);
						hoverObj.material.color.multiplyScalar(1.0 - amount);
						hoverObj.material.color.add(offsetColor);
						event.preventDefault();

						// hoverObj.material.color.g = clamp(hoverObj.material.color.g + diff / 200.0, 0.0, 1.0);
					} else if ((event.type == "mousemove" || event.touches.length == 1)) {
						if (prevPt) {
							var vec = currentPt();
							if (sqdist(vec, prevPt) > PREV_DIST) {
								prevPt = vec;
								addPoint(vec.x, vec.y);
							}
						}
					}
				} else if (MODE == 'transform') {
					if (event.type == "touchmove" && event.touches.length == 3) {
						flipShapes(event);

					} else if ((event.type == "touchmove" && event.touches.length == 2) ||
						(event.type == 'mousemove') && rightClick(event)) {
						if (currentObj != undefined) {
							var k = (pinchDist(event) / startScale) / currentObj.scale.x;
							k = 1;
							var o = pinchAngle(event);
							var c = Math.cos(o - startRotate);
							var s = Math.sin(o - startRotate);
							var p = transformOrigin;

							var m = new THREE.Matrix4();
							m.set(
								k*c, -s*k, 0, k*(-c*p.x + s*p.y) + p.x,
								k*s, k*c, 0, k*(-s*p.x - c*p.y) + p.y,
								0, 0, 1, 0,
								0, 0, 0, 1);
							currentObj.applyMatrix(m);
							startRotate = o;
						}

					} else {
						if (currentObj && currentTransformPt) {
							var vec = currentPt();
							vec.sub(currentTransformPt)
							moveShape(currentObj, vec);
						} else {
							setCurrent(false);
						}
					}
					event.preventDefault();
				}
				event.preventDefault();
			}

			function onDocumentMouseUp(event) {
				debugEvent(event);
				if (currentObj) {
					console.log(currentObj.geometry.boundingSphere);
					currentObj.geometry.computeBoundingSphere();
					console.log(currentObj.geometry.boundingSphere);
				}

				// clear draw
				clearHueShift()
				hoverObj = false;

				// clear transform
				currentTransformPt = false;
				setCurrent(false);

				if (event.type == "mouseup" || event.touches.length == 0) {
					prevPt = false;
					latestDrag = false;
				}
			}

			function onDocumentMouseWheel(event) {
				if (MODE == 'draw') {
					clearHueShift(hueOnly=(event.type == "touchmove"));
					clearLine();

					var delta = mouseDelta(event);
					if (delta && hoverObj) {
						var hsl = new THREE.Color();
						hsl = hoverObj.material.color.getHSL(hsl);
						// var deltaS = delta.x ? clamp(hsl.s + delta.x, 0, 1) : hsl.s;
						var deltaS = hsl.s;
						var deltaL = delta.y ? clamp(hsl.l + delta.y, 0, 1) : hsl.l;

						hoverObj.material.color.setHSL(hsl.h, deltaS, deltaL);
					}
				} else if (MODE == 'transform') {
					flipShapes(event);
				}
				event.preventDefault();
			}

			function debugEvent(event) {
				// console.log(event.type);
				// console.log(event.touches.length);
			}

			function onDocumentResize() {
				var dim = Math.min(window.innerWidth, window.innerHeight) * 0.84;
				document.getElementById("container2").style.width = dim + "px"
				document.getElementById("container2").style.height = dim + "px"
				if (renderer != undefined) {
					renderer.setSize( dim, dim );
					composer.setSize( dim, dim );
					// effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				}
			}

			// Utility
			///////////////////////////////////////////////////////////////////

			function clearHueShift(hueOnly=false) {
				if (lineVisualizer) {
					scene.remove(hueVisualizer);
					hueVisualizer = false;
					if (!hueOnly) {
						scene.remove(lineVisualizer);
						lineVisualizer = false;
					}
					return true;
				}
			}

			function clearLine() {
				if (currentLine) {
					scene.remove(currentLine);
					currentLine = false;
					pos_idx = 0;
					return true;
				}
			}

			function normalizeZDepths() {
				var sorted = scene.children.map(function(a) {
					return {'id': a.id, 'z': a.position.z }
				});
				sorted.sort((a, b) => a.z - b.z);
				var count = 0;
				sorted.map(function(a) {
					if (a.id != squareBG.id) {
						scene.getObjectById(a.id).position.z = count;
						count += 0.99;
					}
				});
			}

			function intersectPt(pt) {
				raycaster.setFromCamera( pt, camera );
				var intersects = raycaster.intersectObjects( [ scene ], true );

				if ( intersects.length > 0 ) {
					intersects.sort((a, b) => b.object.position.z - a.object.position.z);
					return intersects[ 0 ].object;
				}
			}

			function canvasPt(v, flipY=true) {
				var vec = new THREE.Vector3(); // create once and reuse
				var bb = document.getElementById("canvas").getBoundingClientRect();
				var flip = flipY ? -1 : 1;
				vec.set(((v.x) / bb.width) * 2,
					(flip * (v.y) / bb.height) * 2,
					0.5 );
				return vec;
			}

			function pinchDist(event) {
				var p1, p2;
				if (event.touches == undefined) {
					p1 = {x: event.clientX, y: event.clientY};
					p2 = {x: currentObj.geometry.boundingSphere.center.x, y: currentObj.geometry.boundingSphere.center.y};
					return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
				} else if (event.touches.length == 2) {
					return Math.sqrt(
						Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
						Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
					)
				}
			}

			function consoleLog(a) {
				document.getElementById('console').textContent = a;
			}

			function pinchAngle(event) {
				var p1, p2;
				if (currentObj && event.touches == undefined) {
					p1 = currentPt();
					p2 = {x: currentObj.position.x, y: currentObj.position.y};
					var res = Math.atan2((p2.y - p1.y), (p2.x - p1.x));
					return res;

				} else if (event.touches.length == 2) {
					var res = Math.atan2(
						(event.touches[0].clientY - event.touches[1].clientY),
						(event.touches[0].clientX - event.touches[1].clientX)
					)
					return res
				}
			}

			function mouseDelta(event) {
				if (event.type == "touchmove") {
					// three finger drag
					var pt = mouseToCanvasPt();
					if (latestDrag) {
						var delta = {
							x: (pt.x - latestDrag.x),
							y: (pt.y - latestDrag.y)
						};
						latestDrag = pt;
						return delta;
					} else {
						latestDrag = pt;
						return false;
					}
				} else {
					// mouse
					return {
						x: 0.02 * clamp(-event.deltaX, -1, 1),
						y: 0.02 * clamp(-event.deltaY, -1, 1)
					};
				}
			}

			// function getTouchCenter(touches) {
			// 	return new THREE.Vector3(
			// 		touches.reduce((a, b) => ({clientX: a.clientX + b.clientX})).clientX / touches.length,
			// 		touches.reduce((a, b) => ({clientY: a.clientY + b.clientY})).clientY / touches.length,
			// 		0.5);
			// }

			function mouseToCanvasPt() {
				var vec = new THREE.Vector3();

				if (event.touches != undefined) {
					// average all the touch coordinates
					var touches = Object.values(event.touches);
					vec.set(
						touches.reduce((a, b) => ({clientX: a.clientX + b.clientX})).clientX / touches.length,
						touches.reduce((a, b) => ({clientY: a.clientY + b.clientY})).clientY / touches.length,
						0.5);
					// vec.set(event.touches[0].clientX, event.touches[0].clientY, 0.5);
				} else {
					vec.set(event.clientX, event.clientY, 0.5);
				}

				var bb = document.getElementById("canvas").getBoundingClientRect();
				vec.set(((vec.x - bb.left) / bb.width) * 2 - 1,
					(-(vec.y - bb.top) / bb.height) * 2 + 1,
					0.5 );
				return vec;
			}

			function currentPt() {
				var vec = mouseToCanvasPt();
				vec.unproject( camera );
				vec.x = Math.max(-CANVAS_WIDTH, Math.min(vec.x, CANVAS_WIDTH));
				vec.y = Math.max(-CANVAS_HEIGHT, Math.min(vec.y, CANVAS_HEIGHT));
				return vec;
			}

			function sqdist(v1, v2) {
				return (v1.x - v2.x) ** 2 + (v1.x - v2.x) ** 2;
			}

			function clamp(v, a, b) {
				return Math.min(Math.max(v, a), b);
			}

			function rightClick(event) {
				return ("which" in event) ? event.which == 3 : event.button == 2;
			}
		</script>

	</body>
</html>

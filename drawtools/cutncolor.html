<html lang="en">
	<head>
		<title>Shape Color Draw Fun</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
	  rel="stylesheet">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
				color: white;
				text-align: center;
				position: relative;
			}
			#container2 {
				width: 84vw;
				height: 84vw;
				margin: 8vw auto;
				position: relative
			}
			#canvas {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
			}
			#menu {
				display: none;
				opacity: 0.5;
				position: absolute;
				top: 0;
				left: 0;
				margin: 0;
				text-align: left;
				width: 100%;
				height: 100%;
			}
			#menu #menu-container {
				padding: 30px;
				margin: 20px;
				background: black;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				position: absolute;
				overflow-y: scroll;
			}
			#icons {
				position: fixed;
				left: 0;
				bottom: 50px;
				width: 44px;
				height: 44px;
				padding: 0;
				margin: 20px;
			}
			#icons a {
				float: left;
				background: rgba(255, 255, 255, 0.15);
				opacity: 0.7;
				margin: 0;
				padding: 5px;
				width: 60px;
				height: 60px;
				display: none;
			}
			@media only screen and (orientation: landscape) {
				#icon-menu {
					width: 30px;
				}
			}
			#icons a.active {
				display: inline-block;
			}
			#icons a i {
				font-size: 40pt;
			}
			#icon-menu {
				position: fixed;
				left: 0;
				top: 0;
				padding: 0;
				margin: 5px;
			}
			#icon-menu i {
				width: 30px;
				line-height: 30px;
				height: 30px;
				display: inline-block;
				cursor: pointer;
				opacity: 0.3;
				float: left;
				margin: 5px;
			}
			#icon-menu i.active {
				opacity: 1.0;
			}
			.close {
				position: absolute;
				top: 15px;
				right: 15px;
				cursor: pointer;
			}
			.menu-icons i {
				cursor: pointer;
			}
			.menu-icons a {
				color: white;
			}
			p {
				margin: 5px;
			}
			.fixed {
				display: inline-block;
				width: 140px;
			}
			h3, h2 {
				margin-bottom: 0;
			}
		</style>
	</head>
	<body>
		<div id='icon-menu'>
			<a id="toggle-menu" onClick="toggleModal()"><i class="material-icons">help</i></a>
			<a title="shape"><i class="tool-icon material-icons draw-tool active" data-mode="draw">category</i></a>
			<a title="color"><i class="tool-icon material-icons color-tool" data-mode="color">palette</i></a>
			<a title="transform"><i class="tool-icon material-icons transform-tool" data-mode="transform">open_with</i></a>
		</div>

		<div id="container">
			<div id="container2">
				<canvas id="canvas">Your browser does not support Canvas.</canvas>

				<div id="menu">
					<div id="menu-container">
						<i class="material-icons close" onClick="toggleModal()">close</i>
						<div class="menu-icons">
							<a id="download"><i class="material-icons" alt="save" onClick="saveCanvas()">save</i></a>
							<a href="https://github.com/narobins" target="_blank"><i class="material-icons" alt="code">code</i></a>
						</p>
						<h2>About</h2>
						<p>What if drawing interfaces emphasized design decisions (shape, composition, color) rather than mimicking physical media?</p>

						<h2>Usage</h2>
						<h3>Shape mode</h3>
						<p><span class='fixed'>Click and drag</span>: draw shape</p>
						<p><span class='fixed'>Double click</span>: close shape</p>

						<h3>Color mode</h3>
						<p><span class='fixed'>Click</span>: select shape</p>
						<p><span class='fixed'>Click and drag</span>: shift hue</p>
						<p><span class='fixed'>Vertical scroll</span>: shift value</p>

						<h3>Move mode</h3>
						<p><span class='fixed'>Left click drag</span>: move shape</p>
						<p><span class='fixed'>Vertical scroll</span>: bring shape forward/back</p>

						<h2>Stats</h2>
						<p><span id='numShapes'>0</span> shapes, <span id='numVertices'>0</span> vertices</p>
						<br />
					</div>
				</div>
			</div>
		</div>

		<script src="https://threejs.org/build/three.js"></script>

		<script src="https://threejs.org/examples/js/WebGL.js"></script>

		<script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
		<script src="https://threejs.org/examples/js/shaders/FXAAShader.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
		<script src="https://threejs.org/examples/js/postprocessing/OutlinePass.js"></script>

		<script id="hueVisualizeVertex" type="x-shader/x-vertex">

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}

		</script>
		<script id="hueVisualizeFragment" type="x-shader/x-fragment">

		varying vec2 vUv;
		const float pi = 3.14159;

		// All components are in the range [0â€¦1], including hue.
		// this function from stackoverflow
		vec3 hsv2rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}

		void main() {
			gl_FragColor = vec4(1.0);
			vec2 nUv = (vUv.xy - vec2(0.5, 0.5)) * 2.0;
			if (pow(nUv.x, 2.0) + pow(nUv.y, 2.0) < 0.5) {
				discard;
			}
			gl_FragColor.x = (atan(nUv.y, nUv.x)  ) / (2.0 * pi);
			gl_FragColor.xyz = hsv2rgb(gl_FragColor.xyz);
		}

		</script>

		<script>
			console.log('hello');

			// TODO
			// download in new tab?
			//
			// tablet
			// three finger drag, edit mode, switches current shape when you leave shape, also imprecise
			// line for three finger drag edit mode
			// resize keep screen aspect ratio

			var container;
			var camera, scene, renderer, composer, outlinePass, effectFXAA ;
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();

			var MAX_POINTS = 500;
			var PREV_DIST = 80;
			var CANVAS_WIDTH;
			var CANVAS_HEIGHT;
			var START_COLOR = new THREE.Color();
			START_COLOR.setHSL(Math.random(), Math.random() * 0.6 + 0.2, Math.random() * 0.6 + 0.2);
			var HUE_SHIFT_SENSITIVITY = 1.0/150.0;
			var EPSILON = 0.0001;
			var MODE = 'draw';

			// draw
			var p_idx = 0;
			var currentLine = false;
			var prevPt = false;
			var hueShiftColor;
			var squareBG;

			var newShapePt = false;

			// transform
			var currentTransformPt = false;
			var transformOrigin = false;
			var startScale = false;
			var startRotate = 0;
			var currentObj = false;

			var latestTap = new Date().getTime();
			var latestDrag = false;
			var hoverObj = false;

			var lineViz = false;
			var hueViz = false;

			var zCount = 1;
			var MAX_ZDEPTH = 1000;

			var nPts = 0;

			var lastScale = 1;

			onDocumentResize();

			initDim();

			init();
			animate();

			document.getElementById('download').addEventListener('touchstart', function(event) {
				saveCanvas();
			})

			document.getElementById('toggle-menu').addEventListener('touchstart', function(event) {
				toggleModal();
			})
			var toolIcons = document.getElementsByClassName('tool-icon');
			for (var i = 0; i < toolIcons.length; i++) {
				toolIcons[i].addEventListener('mousedown', switchTool)
			}

			function toggleModal() {
				var menu = document.getElementById("menu");
				if (menu.style.display !== "none") {
					menu.style.display = "none";
					MODE = (document.getElementById("draw-tool").className == "active" ? 'draw' : 'transform');
				} else {
					menu.style.display = "block";
					MODE = '';
				}
			}

			function switchTool(e) {
				e.target.className = "material-icons tool-icon active";
				MODE = e.target.getAttribute('data-mode');
				for (var i = 0; i < toolIcons.length; i++) {
					if (toolIcons[i].getAttribute('data-mode') != MODE) {
						toolIcons[i].className = "material-icons tool-icon";
					}
				}
				clearCanvas();
				clearDraw();
			}

			function initDim() {
				bb = document.getElementById("canvas").getBoundingClientRect();
				CANVAS_WIDTH = bb.width;
				CANVAS_HEIGHT = bb.height;
			}

			function init() {
				var bb = document.getElementById("canvas").getBoundingClientRect();

				var aspect = bb.width / bb.height;
				var frustum = bb.height;

				// camera
				camera = new THREE.OrthographicCamera(
					frustum * aspect / - 2,
					frustum * aspect / 2,
					frustum / 2,
					frustum / - 2,
					1,
					2 * MAX_ZDEPTH + 1 );
				camera.position.z = MAX_ZDEPTH + 1;

				scene = new THREE.Scene();

				// setup doc
				var squareMesh = new THREE.PlaneGeometry(CANVAS_WIDTH, CANVAS_HEIGHT)
				var squareMaterial = new THREE.MeshBasicMaterial( { color: START_COLOR } );
				squareBG = new THREE.Mesh(squareMesh, squareMaterial);
				squareBG.position.z = -MAX_ZDEPTH + 1;
				scene.add(squareBG);

				// renderer stuff
				canvas = document.getElementById("canvas");
				container = document.getElementById("container");
				renderer = new THREE.WebGLRenderer({canvas: canvas, preserveDrawingBuffer: true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( bb.width, bb.height );
				renderer.sortElements = false;

				// postprocessing
				composer = new THREE.EffectComposer( renderer );
				composer.setSize( bb.width, bb.height );
				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );

				outlinePass = new THREE.OutlinePass( new THREE.Vector2( bb.width, bb.height ), scene, camera );
				outlinePass.edgeStrength = 0.5;
				outlinePass.edgeGlow = 0;
				outlinePass.edgeThickness = 1;
				outlinePass.visibleEdgeColor.set(0xffffff);
				outlinePass.hiddenEdgeColor.set(0x000000);
				composer.addPass( outlinePass );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				effectFXAA.renderToScreen = true;
				composer.addPass( effectFXAA );

				container.addEventListener( "mousedown", onDocumentMouseDown, false );
				container.addEventListener( "touchstart", onDocumentMouseDown, false );
				container.addEventListener( "mousemove", onDocumentMouseMove, false );
				container.addEventListener( "touchmove", onDocumentMouseMove, false );
				container.addEventListener( "mouseup", onDocumentMouseUp, false );
				container.addEventListener( "touchend", onDocumentMouseUp, false );
				container.addEventListener( "wheel", onDocumentMouseWheel, false );

				window.addEventListener( "resize", onDocumentResize, false );
				document.addEventListener("keypress", onKeyPress, false);
			}

			function checkIntersection(event) {
				var mouse = mouseToCanvasPt();
				var obj = intersectPt(mouse);
				return obj;
			}

			function startNewShape(vec) {
				clearDraw();
				newShapePt = debugPt(new THREE.Vector3(vec.x, vec.y), 0xffffff);

				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
				geometry.addAttribute( "position", new THREE.BufferAttribute( positions, 3 ) );
				drawCount = 0; // draw the first 2 points, only
				geometry.setDrawRange( 0, 0 );

				var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } );
				currentLine = new THREE.Line( geometry,  material );
				currentLine.position.z = zCount;
				scene.add( currentLine );
			}

			function setCurrent(obj) {
				currentObj = obj;
				outline(obj);
				return currentObj;
			}

			function outline(mesh) {
				if (mesh) {
					outlinePass.selectedObjects = [mesh];
				} else {
					outlinePass.selectedObjects = [];
				}
			}

			function addPoint(x, y) {
				if (!currentLine) {
					var vec = new THREE.Vector3(x, y, 0.5);
					startNewShape(vec);
					var intersection = intersectPt(canvasPt({'x': x, 'y': y}));
					if (intersection != undefined) {
						var hsl = new THREE.Color();
						hsl = intersection.material.color.getHSL(hsl);
						if (hsl.l < 0.4) {
							currentLine.material.color.r = 1.0;
							currentLine.material.color.g = 1.0;
							currentLine.material.color.b = 1.0;
						}
					}
				}
				var positions = currentLine.geometry.attributes.position.array;

				positions[ p_idx ++ ] = x;
				positions[ p_idx ++ ] = y;
				positions[ p_idx ++ ] = 0;

				currentLine.geometry.setDrawRange( 0, p_idx / 3 );
				currentLine.geometry.attributes.position.needsUpdate = true;
			}

			function avgSampleColors(pts) {
				var sample;
				var avg = new THREE.Color(0,0,0);
				var quarter = Math.floor(Math.max(8, pts.length) / 8);
				var nSamples = 0;

				for (var j = 0; j < pts.length; j+=quarter) {
					// normalize pt, but don't flip y
					sample = intersectPt(canvasPt(pts[j], flipY=false));
					if (sample != undefined) {
						nSamples += 1;
						avg.add(sample.material.color);
					}
				}
				if (!nSamples) {
					// no samples taken, probably all around edges
					avg.copy(squareBG.material.color);
					nSamples = 1;
				}
				return avg.multiplyScalar(1.0 / nSamples);
			}

			function offsetRandom(scale, offset) {
				return (2 * Math.round(Math.random()) - 1) * ((Math.random() * scale) + offset);
			}

			function closeShape() {
				// turns current line into a polygon (multiple polygons if the line is self-intersecting)
				if (currentLine) {
					currentLine.geometry.computeBoundingSphere();
					var center = new THREE.Vector3();
					center.copy(currentLine.geometry.boundingSphere.center);

					var p = currentLine.geometry.attributes.position.array;
					var n_pts = p_idx;
					p[ p_idx ++ ] = p[0];
					p[ p_idx ++ ] = p[1];
					p[ p_idx ++ ] = p[2];

					function getPt(i) {
						return new THREE.Vector3(p[i], p[i+1]);
					}

					function countIntersections(start, vec, i) {
						// a point is inside a filled area of the polygon if its
						// corresponding ray has an odd number of intersections
						var s = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT);
						var end = new THREE.Vector3(start.x + s * vec.x, start.y + s * vec.y);
						var j = 0;
						var count = 0;
						while (j < n_pts) {
							var intersect;
							if (ptsIntersect(start, end, getPt(j), getPt(j+3))) {
								count += 1;
							}
							j += 3;
						}
						return count % 2 == 1;
					}

					function chooseDirection(start, intersect, a, b, i) {
						// every intersection has two filled and two unfilled quadrants, chooses
						// the direction such that the path will hug the filled quadrant
						var original = new THREE.Vector2(start.x - intersect.x, start.y - intersect.y).normalize();
						var a_pt = getPt(a);
						var b_pt = getPt(b);
						var a_v = new THREE.Vector2(a_pt.x - intersect.x, a_pt.y - intersect.y).normalize();
						var b_v = new THREE.Vector2(p[b] - intersect.x, p[b + 1] - intersect.y).normalize();
						var a_avg = new THREE.Vector2((original.x + a_v.x) / 2, (original.y + a_v.y) / 2).normalize();
						var b_avg = new THREE.Vector2((original.x + b_v.x) / 2, (original.y + b_v.y) / 2).normalize();

						if (countIntersections(intersect, a_avg, i)) {
							return true;
						} else if (countIntersections(intersect, b_avg, i)) {
							return false;
						} else {
							debugPt(intersect, 0xff0000);
							throw new Error('both cant be clockwise');
						}
					}

					function getIntersection(start, end, i) {
						// returns an intersection of the line from start to end
						// (the intersection closest to the start pt)
						var j = 0;
						var res = undefined;
						var a;
						var b;
						while (j < p_idx - 3) {
							var intersect;
							if (!(i == j || i == j + 3)) {
							// if (i_intersection || !(i == j || i == j + 3)) {
								intersect = ptsIntersect(start, end, getPt(j), getPt(j+3));
								if (intersect) {
									if (res == undefined || sqdist(start, res) > sqdist(start, intersect)) {
										res = intersect;
										a = j;
										b = j + 3;
									}
								}
							}
							j += 3;
						}
						return {
							'cross': res,
							'a': a,
							'b': b
						};
					}

					var i = 0;
					var queue = [[i, new THREE.Vector2(p[i], p[i+1]), 1, false]];
					var shapes = [];
					var limit = 0;

					function trace(i, p_this, dir, i_intersection) {
						var pts = [];
						var visited = [];

						var i_next = i_intersection ? i : i + dir * 3;
						var p_next = new THREE.Vector2(p[i_next], p[i_next + 1]);

						function addPt(p) {
							pts.push(new THREE.Vector2( p.x - center.x, p.y - center.y ));
						}

						while ((i < n_pts || i_intersection) && limit < 1000) {
							limit += 1;
							addPt(p_this);

							i_next = i_intersection ? i : i + 3 * dir;
							p_next = getPt(i_next);

							if (!i_intersection) {
								if (visited.includes((i % n_pts) / 3)) {
									return pts;
								}
								visited.push((i % n_pts) / 3);
							}

							var r = getIntersection(p_this, p_next, i);
							var cross = r.cross;
							var a = r.a;
							var b = r.b;

							if (cross != undefined) {
								choice = chooseDirection(p_this, cross, a, b, i);
								i = choice ? a : b;
								i_other = choice ? b : a;
								i_intersection = true;
								p_this = cross;

								// dir is positive if we chose the higher index
								dir = (i == Math.max(a, b) || (Math.min(a, b) == 0)) ? 1 : -1;

								// save the other direction for later
								var later = [i_other, getPt(i_other), -dir, true];
								queue.push(later);

							} else {
								p_this = p_next;
								i = i_next;
								i_intersection = false;
							}
						}
						return pts;
					}

					var queueOld = [];

					function beenVisited(v, q) {
						for (var idx; idx < q.length; idx++) {
							if (v[0] === q[idx][0] &&
								v[1].x === q[idx][1].x &&
								v[1].y === q[idx][1].y &&
								v[2] === q[idx][2] &&
								v[3] === q[idx][3]) {
								return true;
							}
						}
						return false;
					}

					var visiting = queue.pop();
					while (visiting != undefined) {
						if (!beenVisited(visiting, queueOld) && !beenVisited(visiting, queue)) {
							var path = trace(visiting[0], visiting[1], visiting[2], visiting[3]);
							if (path.length > 0) {
								shapes.push(new THREE.Shape(path));
							}
							queueOld.push(visiting);
						}
						visiting = queue.pop();
					}

					var avg = avgSampleColors(shapes[0]);
					avg.offsetHSL(offsetRandom(0.03, 0.01), offsetRandom(0.05, 0.03), offsetRandom(0.03, 0.06));

					var geometry = new THREE.ShapeBufferGeometry( shapes );
					var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: avg } ));
					scene.add(mesh);
					mesh.position.x = center.x;
					mesh.position.y = center.y;
					mesh.position.z = zCount;
					zCount += 0.99;
					clearLine();

					numVertices = 0;
					scene.children.map(function(a) {
						if (a.id != squareBG.id && a.geometry.attributes != undefined) {
							numVertices += a.geometry.attributes.position.count;
						}
					});
					document.getElementById('numVertices').textContent = String(numVertices)
					document.getElementById('numShapes').textContent = String(scene.children.length - 1)
				}

				clearDraw();
			}

			function debugPt(vec, c) {
				c = c || 0xffffff;
				var geometry = new THREE.CircleGeometry( 4, 4 );
				var material = new THREE.MeshBasicMaterial({color:c});
				var pt = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({color:c}) );
				pt.position.x = vec.x;
				pt.position.y = vec.y;
				pt.position.z = MAX_ZDEPTH;
				scene.add( pt );
				return pt;
			}

			function showLineModal(vec, c) {
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));

				lineViz = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color: c } ) );
				lineViz.position.z = zCount;
				scene.add( lineViz );
			}

			function debugLine(pt1, pt2, c) {
				var pta = new THREE.Vector3();
				var ptb = new THREE.Vector3();
				pta.copy(pt1);
				ptb.copy(pt2);
				var jitter = 0;
				pta.x += Math.random() * jitter;
				pta.y += Math.random() * jitter;
				// pta.z = 0;
				ptb.x -= Math.random() * jitter;
				ptb.y -= Math.random() * jitter;
				// ptb.z = 0;

				var geo = new THREE.Geometry();
				geo.vertices.push(pta);
				geo.vertices.push(ptb);

				var line = new THREE.Line( geo, new THREE.LineBasicMaterial( { color: c } ) );
				line.position.z = zCount;
				scene.add( line );
			}

			function debugVec(pt, v) {
				var pt2 = new THREE.Vector3(pt.x + 30 * v.x, pt.y + 30 * v.y);
				return debugLine(pt, pt2, 0x00ffff);
			}

			function setLineModal(vec) {
				lineViz.geometry.vertices[1].x = vec.x;
				lineViz.geometry.vertices[1].y = vec.y;
				lineViz.geometry.verticesNeedUpdate = true;
			}

			function showHueWheel(vec, c) {
				var hsl = new THREE.Color();
				hsl = c.getHSL(hsl);
				console.log(hsl);
				var lineColor = hsl.l < 0.4 ? 0xffffff : 0x000000;
				console.log(lineColor);
				showLineModal(vec, lineColor);

				var circleGeo = new THREE.CircleGeometry( 20, 24 );
				var circleMat = new THREE.ShaderMaterial({
					vertexShader: document.getElementById("hueVisualizeVertex").textContent,
					fragmentShader: document.getElementById("hueVisualizeFragment").textContent,
					depthWrite: false,
					depthTest: false
				});
				hueViz = new THREE.Mesh( circleGeo, circleMat );
				hueViz.position.x = vec.x;
				hueViz.position.y = vec.y;
				scene.add( hueViz );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				composer.render();
			}

			// Color
			///////////////////////////////////////////////////////////////////

			function startHueShift(event) {
				clearLine();
				hoverObj = checkIntersection(event);
				if (hoverObj && hoverObj.material.color) {
					hueShiftColor = hoverObj.material.color.clone();
					showHueWheel(currentPt(), hueShiftColor);
					event.preventDefault();
					event.stopPropagation();
				}
			}

			function shiftHue(event) {
				if (!hoverObj || !lineViz) {
					startHueShift(event);
				}

				clearLine();
				prevPt = false;
				var vec = currentPt();
				// vec.z = 0;
				setLineModal(vec);

				var diff = new THREE.Vector2(
					lineViz.geometry.vertices[1].x - lineViz.geometry.vertices[0].x,
					lineViz.geometry.vertices[1].y - lineViz.geometry.vertices[0].y,
				);
				var degrees = Math.atan2(diff.y, diff.x) / (2.0 * Math.PI);
				var amount = Math.min(diff.length() * HUE_SHIFT_SENSITIVITY, 1.0);

				hoverObj.material.color.set(hueShiftColor);

				// adjust hue in a copy of the color
				var offsetColor = new THREE.Color();
				hoverObj.material.color.getHSL(offsetColor);
				offsetColor.setHSL(degrees, 1.0, offsetColor.l);

				// mix offset color back into original color
				offsetColor.multiplyScalar(amount);
				hoverObj.material.color.multiplyScalar(1.0 - amount);
				hoverObj.material.color.add(offsetColor);
				event.preventDefault();
			}

			function shiftValue(event) {
				prevPt = false;

				if (!hoverObj) {
					hoverObj = checkIntersection(event);
				}
				if (!lineViz) {
					showLineModal(currentPt());
				}

				onDocumentMouseWheel(event);

				var vec = currentPt();
				lineViz.geometry.vertices[1].x = vec.x;
				lineViz.geometry.vertices[1].y = vec.y;
				lineViz.geometry.verticesNeedUpdate = true;
			}

			// Transform
			///////////////////////////////////////////////////////////////////
			function moveShape(shape, delta) {
				var center = {
					'x': shape.position.x,
					'y': shape.position.y,
				};

				var p = {
					'x': transformOrigin.x + delta.x,
					'y': transformOrigin.y + delta.y,
				};
				shape.applyMatrix(new THREE.Matrix4().makeTranslation(p.x - center.x, p.y - center.y, 0) );
			}

			function flipShapes(event) {
				currentObj = currentObj || checkIntersection(event);
				if (currentObj && currentObj.id != squareBG.id) {
					var delta = mouseDelta(event);
					if (event.type == "touchmove") {
						delta *= -1;
					}
					outline(currentObj);
					currentObj.position.z = currentObj.position.z + (delta.y > 0 ? -1 : 1);
					zCount = Math.max(currentObj.position.z, zCount);
					normalizeZDepths();
				}
			}

			function scaleRotateTransform(event) {
				if (currentObj != undefined) {

					var k = (pinchDist(event) / startScale) / currentObj.scale.x;
					if (!lineViz) {
						showLineModal(currentPt());
					}
					setLineModal(currentPt());

					var o = pinchAngle(event);
					var c = Math.cos(o - startRotate);
					var s = Math.sin(o - startRotate);
					var p = transformOrigin;

					var m = new THREE.Matrix4();
					m.set(
						k*c, -s*k, 0, k*(-c*p.x + s*p.y) + p.x,
						k*s, k*c, 0, k*(-s*p.x - c*p.y) + p.y,
						0, 0, 1, 0,
						0, 0, 0, 1);
					currentObj.applyMatrix(m);
					startRotate = o;
				}
			}

			function getObjectPos(obj) {
				return {
					'x': obj.position.x,
					'y': obj.position.y
				}
			}

			// Clearing
			///////////////////////////////////////////////////////////////////

			function clearDraw() {
				if (newShapePt) {
					scene.remove(newShapePt);
					newShapePt = false;
				}
			}

			function clearCanvas() {
				if (currentObj) {
					currentObj.geometry.computeBoundingSphere();
				}

				// clear color
				clearHueShift()
				hoverObj = false;

				// clear transform
				currentTransformPt = false;
				setCurrent(false);
			}

			function clearHueShift(hueOnly=false) {
				if (lineViz) {
					scene.remove(hueViz);
					hueViz = false;
					if (!hueOnly) {
						scene.remove(lineViz);
						lineViz = false;
					}
					return true;
				}
			}

			function clearLine() {
				if (currentLine) {
					scene.remove(currentLine);
					currentLine = false;
					p_idx = 0;
					return true;
				}
			}

			// Events
			///////////////////////////////////////////////////////////////////
			// disable right click menu
			// document.oncontextmenu = function () {
			// 	return false;
			// };

			function saveCanvas() {
				var img = document.getElementById("canvas").toDataURL().replace("image/png", "image/octet-stream");
				document.getElementById("download").setAttribute("href", img);
				document.getElementById("download").setAttribute("download", "asdf.png");
			}

			function onKeyPress() {
				closeShape();
			}

			function onDocumentMouseDown(event) {
				if (MODE == 'draw') {

					if (event.type === "mousedown" || event.touches != undefined) {
						if (doubleClick(event)) {
							// double click > close shape, but only for mouse or single finger
							closeShape();

						} else {
							// add point
							var vec = currentPt();
							prevPt = vec;
							addPoint(vec.x, vec.y);
						}
						event.preventDefault();
					}

				} else if (MODE == 'color') {
					if ((event.type == 'mousedown' && leftClick(event)) ||
						(event.type == 'touchstart' && event.touches == 2)) {
						startHueShift(event);

					} else if (event.type == 'touchstart' && event.touches == 1) {
						var intersected = checkIntersection(event);
						if (intersected && intersected.id != squareBG.id) {
							currentObj = setCurrent(intersected);
						}
					}
					event.preventDefault();

				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected && intersected.id != squareBG.id) {
						currentObj = setCurrent(intersected);
						if (currentObj) {
							currentTransformPt = currentPt();

							if ((event.type == 'mousedown' && !rightClick(event)) ||
								(event.touches && event.touches.length == 1)) {
								transformOrigin = getObjectPos(currentObj);

							} else if ((event.touches && event.touches.length == 2) ||
								(event.type == 'mousedown') && rightClick(event)) {
								startScale = pinchDist(event) / currentObj.scale.x;
								startRotate = pinchAngle(event);
								showLineModal(pinchCenter(event));

								if (event.type == 'mousedown') {
									transformOrigin = currentObj.position;
								}
							}
						}
					}
				}
				event.preventDefault();
			}

			function onDocumentMouseMove(event) {
				if (MODE == 'draw') {

					if ((event.type == "mousemove" || event.touches.length == 1)) {
						if (prevPt) {
							var vec = currentPt();
							if (sqdist(vec, prevPt) > PREV_DIST) {
								prevPt = vec;
								addPoint(vec.x, vec.y);
							}
						}
					}

				} else if (MODE == 'color') {

					if (event.type == "touchmove" && event.touches.length == 3) {

						shiftValue(event);

					} else if ((event.type == "mousemove" && event.buttons == 1) ||
							(event.type == "touchmove" && event.touches.length == 2)) {

						shiftHue(event);
					}

				} else if (MODE == 'transform') {
					if (currentObj && currentTransformPt) {
						if (event.type == "touchmove" && event.touches.length == 3) {
							flipShapes(event);

						} else if ((event.type == "touchmove" && event.touches.length == 2) ||
							(event.type == 'mousemove') && rightClick(event)) {

							scaleRotateTransform(event);

						} else {
							var vec = currentPt();
							vec.sub(currentTransformPt)
							moveShape(currentObj, vec);
						}
					} else {
						setCurrent(false);
					}
					event.preventDefault();
				}
				event.preventDefault();
			}

			function onDocumentMouseUp(event) {
				if (MODE == "draw" || MODE == "transform" ||
					(MODE == "color" && event.type == "mouseup")) {
					if (currentObj) {
						currentObj.geometry.computeBoundingSphere();
					}

					// clear draw
					clearHueShift()
					hoverObj = false;

					// clear transform
					currentTransformPt = false;

					setCurrent(false);
				}

				if (event.type == "mouseup" || event.touches.length == 0) {
					prevPt = false;
					latestDrag = false;
				}
			}

			function onDocumentMouseWheel(event) {
				if (MODE == "color") {
					clearHueShift(hueOnly=(event.type == "touchmove"));
					clearLine();

					if (event.type != "touchmove") {
						hoverObj = checkIntersection(event);
					}
					var delta = mouseDelta(event);
					if (delta && hoverObj) {
						var hsl = new THREE.Color();
						hsl = hoverObj.material.color.getHSL(hsl);
						// var deltaS = delta.x ? clamp(hsl.s + delta.x, 0, 1) : hsl.s;
						var deltaS = hsl.s;
						var deltaL = delta.y ? clamp(hsl.l + delta.y, 0, 1) : hsl.l;

						hoverObj.material.color.setHSL(hsl.h, deltaS, deltaL);
					}

				} else if (MODE == "transform") {
					flipShapes(event);
				}
				event.preventDefault();
			}

			function onDocumentResize() {
				var dim = Math.min(window.innerWidth, window.innerHeight) * 0.84;
				document.getElementById("container2").style.width = dim + "px"
				document.getElementById("container2").style.height = dim + "px"
				if (renderer != undefined) {
					renderer.setSize(dim, dim);
					composer.setSize(dim, dim);
					// effectFXAA.uniforms[ "resolution" ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				}
			}

			// Utility
			///////////////////////////////////////////////////////////////////

			function normalizeZDepths() {
				var sorted = scene.children.map(function(a) {
					return {"id": a.id, "z": a.position.z }
				});
				sorted.sort((a, b) => a.z - b.z);
				var count = 0;
				sorted.map(function(a) {
					if (a.id != squareBG.id) {
						scene.getObjectById(a.id).position.z = count;
						count += 0.99;
					}
				});
			}

			function intersectPt(pt) {
				raycaster.setFromCamera( pt, camera );
				var intersects = raycaster.intersectObjects( [ scene ], true );

				if ( intersects.length > 0 ) {
					intersects.sort((a, b) => b.object.position.z - a.object.position.z);
					return intersects[ 0 ].object;
				}
			}

			function canvasPt(v, flipY=true) {
				var bb = document.getElementById("canvas").getBoundingClientRect();
				var flip = flipY ? -1 : 1;
				return new THREE.Vector3(((v.x) / bb.width) * 2,
					(flip * (v.y) / bb.height) * 2,
					0.5 );
			}

			function pinchCenter(event) {
				if (event.touches == undefined) {
					return {x: currentObj.position.x, y: currentObj.position.y};
				} else {
					return {
						x: (event.touches[0].clientY - event.touches[1].clientY) / 2,
						y: (event.touches[1].clientX - event.touches[0].clientX) / 2
					}
				}
			}

			function pinchDist(event) {
				if (event.touches == undefined) {
					var p1 = currentPt();
					var p2 = {x: currentObj.position.x, y: currentObj.position.y};
					return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
				} else if (event.touches.length == 2) {
					return Math.sqrt(
						Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
						Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
					)
				}
			}

			function pinchAngle(event) {
				var p1, p2;
				if (currentObj && event.touches == undefined) {
					p1 = currentPt();
					p2 = {x: currentObj.position.x, y: currentObj.position.y};
					return Math.atan2((p2.y - p1.y), (p2.x - p1.x));

				} else if (event.touches.length == 2) {
					return Math.atan2(
						(event.touches[0].clientY - event.touches[1].clientY),
						(event.touches[1].clientX - event.touches[0].clientX)
					)
				}
			}

			function mouseDelta(event) {
				if (event.type == "touchmove") {
					// three finger drag
					var pt = mouseToCanvasPt();
					if (latestDrag) {
						var delta = {
							x: (pt.x - latestDrag.x),
							y: (pt.y - latestDrag.y)
						};
						latestDrag = pt;
						return delta;
					} else {
						latestDrag = pt;
						return false;
					}
				} else {
					// mouse
					return {
						x: 0.02 * clamp(-event.deltaX, -1, 1),
						y: 0.02 * clamp(-event.deltaY, -1, 1)
					};
				}
			}

			function mouseToCanvasPt() {
				var vec = new THREE.Vector3();

				if (event.touches != undefined) {
					// average all the touch coordinates
					var touches = Object.values(event.touches);
					vec.set(
						touches.reduce((a, b) => ({clientX: a.clientX + b.clientX})).clientX / touches.length,
						touches.reduce((a, b) => ({clientY: a.clientY + b.clientY})).clientY / touches.length,
						0.5);
				} else {
					vec.set(event.clientX, event.clientY, 0.5);
				}

				var bb = document.getElementById("canvas").getBoundingClientRect();
				vec.set(((vec.x - bb.left) / bb.width) * 2 - 1,
					(-(vec.y - bb.top) / bb.height) * 2 + 1,
					0.5 );
				return vec;
			}

			function currentPt() {
				var vec = mouseToCanvasPt();
				vec.unproject( camera );
				vec.x = clamp(vec.x, -CANVAS_WIDTH, CANVAS_WIDTH);
				vec.y = clamp(vec.y, -CANVAS_HEIGHT, CANVAS_HEIGHT);
				return vec;
			}

			function sqdist(v1, v2) { return (v1.x - v2.x) ** 2 + (v1.x - v2.x) ** 2; }

			function clamp(v, a, b) { return Math.min(Math.max(v, a), b); }

			function clockwise(v1, v2) { return !(v1.y * v2.x > v1.x * v2.y); }

			function rightClick(event) { return ("which" in event) ? event.which == 3 : event.button == 2; }

			function leftClick(event) { return ("which" in event) ? event.which == 1 : event.button == 0; }

			function doubleClick(event) {
				var now = new Date().getTime();
				var since = now - latestTap;
				latestTap = new Date().getTime();

				return (since < 200 && since > 0 && (event.touches == undefined || event.touches.length == 1));
			}

			function singleTap(event) {
				var now = new Date().getTime();
				var since = now - latestTap;
				latestTap = new Date().getTime();

				return (since < 200 && since > 0 && (event.touches == undefined || event.touches.length == 1));
			}

			// returns true iff the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
			//https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function#15182022
			function intersects(a,b,c,d,p,q,r,s) {
				var det, gamma, lambda;
				det = (c - a) * (s - q) - (r - p) * (d - b);
				if (det === 0) {
					return false;
				} else {
					lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
					gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
					if ((EPSILON < lambda && lambda < (1 - EPSILON)) && (EPSILON < gamma && gamma < (1 - EPSILON))) {
						return new THREE.Vector3(
							a + lambda * (c-a),
							b + lambda * (d-b),
						);
					} else {
						return undefined;
					}
				}
			}

			function ptsIntersect(p, q, r, s) {
				return intersects(p.x, p.y, q.x, q.y, r.x, r.y, s.x, s.y);
			}

		</script>

	</body>
</html>

<html lang="en">
	<head>
		<title>three.js canvas - geometry - shapes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
	  rel="stylesheet">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
				color: white;
				text-align: center;
				position: relative;
			}
			#canvas {
				width: 84vw;
				height: 84vw;
				margin: 8vw auto;
			}
			#menu {
				display: none;
				opacity: 0.5;
				background: black;
				position: fixed;
				left: 20vw;
				top: 20vh;
				width: 60vw;
				height: 60vh;
				text-align: left;
			}
			#menu #menu-container {
				margin: 50px;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				position: absolute;
			}
			#icons {
				position: fixed;
				left: 0;
				width: 50px;
				height: 50px;
				padding: 0;
				margin: 20px;
			}
			#icons a {
				float: left;
				background: rgba(255, 255, 255, 0.15);
				opacity: 0.7;
				margin: 0;
				padding: 5px;
				width: 40px;
				height: 40px;
				cursor: pointer;
				display: none;
			}
			@media only screen and (orientation: landscape) {
				#icons {
					top: 50%;
					margin-top: -75px;
					height: 150px;
				}
				#icons a {
					height: 140px;
					vertical-align: middle;
				}
				#icons a i {
					line-height: 140px;
				}
			}
			@media only screen and (orientation: portrait) {
				#icons {
					left: 0;
					right: 0;
					bottom: 0;
					margin-left: auto;
					margin-right: auto;
					width: 150px;
				}
				#icons a {
					width: 140px;
				}
			}
			#icons a.active {
				display: inline-block;
			}
			#icons a i {
				font-size: 28pt;
			}
			#toggle-menu {
				position: fixed;
				left: 0;
				top: 0;
				font-size: 18pt;
				cursor: pointer;
				padding: 10px;
			}
			.close {
				float: right;
				cursor: pointer;
			}
			.icons {
				bottom: 0;
				position: absolute;
			}
			.icons i {
				cursor: pointer;
			}
			.icons a {
				color: white;
			}
			p {
				margin: 5px 0;
			}
		</style>
	</head>
	<body>
		<a id="toggle-menu" onClick="toggleModal()">?</a>
		<div id="icons">
			<a id="draw-tool" title="move mode" class="active" onClick="transformTool()"><i class="material-icons">open_with</i></a>
			<a id="transform-tool" title="draw mode" onClick="drawTool()"><i class="material-icons">edit</i></a>
		</div>
		<div id="menu">
			<div id="menu-container">
				<i class="material-icons close" onClick="toggleModal()">close</i>
				<p>What if drawing interfaces emphasized design principles (shape, composition, color) rather than mimicking physical media?</p>
				<h2>Usage</h2>
				<h3>Draw mode</h3>
				<p>Left click drag: draw shape</p>
				<p>Double click: close shape</p>
				<p>Right click drag: shift hue</p>
				<p>Vertical scroll: shift value</p>
				<p>Horizontal scroll: shift saturation</p>
				<h3>Move mode</h3>
				<p>Left click drag: move shape</p>
				<p>Vertical scroll: bring shape forward/back</p>
				<br />
				<p class="icons">
					<a id="download"><i class="material-icons" alt="save" onClick="saveCanvas()">save</i></a>
					<a href="https://github.com/narobins" target="_blank"><i class="material-icons" alt="code">code</i></a>
				</p>
			</div>
		</div>
		<div id="container">
			<canvas id="canvas">Your browser does not support Canvas.</canvas>
		</div>

		<script src="three.min.js"></script>
		<!-- <script src="https://threejs.org/build/three.js"></script> -->

		<script id="hueVisualizeVertex" type="x-shader/x-vertex">

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}

		</script>
		<script id="hueVisualizeFragment" type="x-shader/x-fragment">

		varying vec2 vUv;
		const float pi = 3.14159;

		// All components are in the range [0â€¦1], including hue.
		vec3 hsv2rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}

		void main() {
			gl_FragColor = vec4(1.0);
			vec2 nUv = (vUv.xy - vec2(0.5, 0.5)) * 2.0;
			if (pow(nUv.x, 2.0) + pow(nUv.y, 2.0) < 0.5) {
				discard;
			}
			gl_FragColor.x = (atan(nUv.y, nUv.x)  ) / (2.0 * pi);
			gl_FragColor.xyz = hsv2rgb(gl_FragColor.xyz);
		}

		</script>

		<script>
			var container;
			var camera, scene, renderer;
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();

			var MAX_POINTS = 500;
			var PREV_DIST = 80;
			var CANVAS_WIDTH;
			var CANVAS_HEIGHT;
			var START_COLOR = new THREE.Color("hsl(80, 50%, 80%)");
			var HUE_SHIFT_SENSITIVITY = 1.0/150.0;
			var MODE = 'draw';

			// draw
			var pos_idx = 0;
			var currentLine = false;
			var prevPt = false;
			var hueShiftColor;
			var squareBG;

			// transform
			var startTransformPt = false;
			var startTransformPos = false;
			var currentObj = false;

			var latestTap = new Date().getTime();
			var latestDrag = false;
			var hoverObj = false;

			var visualizer = false;
			var hueVisualizer = false;

			var zCount = 1;
			var MAX_ZDEPTH = 1000;

			onDocumentResize();

			initDim();

			init();
			animate();

			function toggleModal() {
				var menu = document.getElementById("menu");
				if (menu.style.display !== "none") {
					menu.style.display = "none";
				}
				else {
					menu.style.display = "block";
				}
			}

			function drawTool() {
				document.getElementById("draw-tool").className = "active";
				document.getElementById("transform-tool").className = "";
				document.getElementById("toggle-menu").className = "";
				MODE = 'draw';
				document.body.style.cursor = 'crosshair';
			}

			function transformTool() {
				document.getElementById("draw-tool").className = "";
				document.getElementById("transform-tool").className = "active";
				document.getElementById("toggle-menu").className = "";
				MODE = 'transform';
				document.body.style.cursor = 'move';
			}

			function initDim() {
				bb = document.getElementById("canvas").getBoundingClientRect();
				CANVAS_WIDTH = bb.width;
				CANVAS_HEIGHT = bb.height;
			}

			function init() {
				container = document.getElementById( "container" );
				var bb = document.getElementById("canvas").getBoundingClientRect();

				var aspect = bb.width / bb.height;
				var frustumSize = bb.height;

				// camera
				camera = new THREE.OrthographicCamera(
					frustumSize * aspect / - 2,
					frustumSize * aspect / 2,
					frustumSize / 2,
					frustumSize / - 2,
					1,
					2 * MAX_ZDEPTH + 1 );
				camera.rotation.x = 0;
				camera.rotation.y = 0;
				camera.rotation.z = 0;
				camera.position.x = 0;
				camera.position.y = 0;
				camera.position.z = MAX_ZDEPTH + 1;

				scene = new THREE.Scene();

				// setup doc
				var squareMesh = new THREE.PlaneGeometry(CANVAS_WIDTH, CANVAS_HEIGHT)
				var squareMaterial = new THREE.MeshBasicMaterial( { color: START_COLOR } );
				squareBG = new THREE.Mesh(squareMesh, squareMaterial);
				squareBG.position.z = -MAX_ZDEPTH;
				scene.add(squareBG);

				// renderer stuff
				canvas = document.getElementById("canvas");
				container = document.getElementById("container");


				renderer = new THREE.WebGLRenderer({canvas: canvas, preserveDrawingBuffer: true, antialias: true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( bb.width, bb.height );
				renderer.sortElements = false;

				container.addEventListener( "mousedown", onDocumentMouseDown, false );
				container.addEventListener( "touchstart", onDocumentMouseDown, false );

				container.addEventListener( "mousemove", onDocumentMouseMove, false );
				container.addEventListener( "touchmove", onDocumentMouseMove, false );

				container.addEventListener( "mouseup", onDocumentMouseUp, false );
				container.addEventListener( "touchend", onDocumentMouseUp, false );

				container.addEventListener( "wheel", onDocumentMouseWheel, false );

				window.addEventListener( "resize", onDocumentResize, false );

				document.addEventListener("keypress", onKeyPress, false);
			}

			function checkIntersection(event) {
				var mouse = mouseToCanvasPt();
				return intersectPt(mouse);
			}

			function startNewShape() {
				var geometry = new THREE.BufferGeometry();
				var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
				geometry.addAttribute( "position", new THREE.BufferAttribute( positions, 3 ) );
				drawCount = 0; // draw the first 2 points, only
				geometry.setDrawRange( 0, 0 );

				var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } );
				currentLine = new THREE.Line( geometry,  material );
				currentLine.position.z = zCount;
				scene.add( currentLine );
			}

			function addPoint(x, y) {
				if (!currentLine) {
					startNewShape();
					var vec = new THREE.Vector3(x, y, 0.5);
					var intersects = intersectPt(canvasPt({'x': x, 'y': y}));
					if (intersects != undefined) {
						var hsl = new THREE.Color();
						hsl = intersects.material.color.getHSL(hsl);
						if (hsl.l < 0.4) {
							currentLine.material.color.r = 1.0;
							currentLine.material.color.g = 1.0;
							currentLine.material.color.b = 1.0;
						}
					}
				}
				var positions = currentLine.geometry.attributes.position.array;

				positions[ pos_idx ++ ] = x;
				positions[ pos_idx ++ ] = y;
				positions[ pos_idx ++ ] = 0;

				currentLine.geometry.setDrawRange( 0, pos_idx / 3 );
				currentLine.geometry.attributes.position.needsUpdate = true;
			}

			function avgSampleColors(pts) {
				var sample;
				var avg = new THREE.Color(0,0,0);
				var quarter = Math.floor(Math.max(8, pts.length) / 8);
				var nSamples = 0;

				for (var j = 0; j < pts.length; j+=quarter) {
					sample = intersectPt(canvasPt(pts[j]));
					if (sample != undefined) {
						nSamples += 1;
						avg.add(sample.material.color);
					}
				}
				if (!nSamples) {
					// no samples taken, probably all around edges
					avg.copy(squareBG.material.color);
					nSamples = 1;
				}
				return avg.multiplyScalar(1.0 / nSamples);
			}

			function offsetRandom(scale, offset) {
				return (2 * Math.round(Math.random()) - 1) * ((Math.random() * scale) + offset);
			}

			function closeShape() {
				if (currentLine) {
					var positions = currentLine.geometry.attributes.position.array;
					positions[ pos_idx ++ ] = positions[0];
					positions[ pos_idx ++ ] = positions[1];
					positions[ pos_idx ++ ] = positions[2];

					// make closed shape from line pts
					var pts = [];
					for (var i = 0; i < pos_idx; i+=3) {
						pts.push(new THREE.Vector2( positions[i], positions[i+1] ));
					}

					var avg = avgSampleColors(pts);
					avg.offsetHSL(offsetRandom(0.03, 0.02), offsetRandom(0.05, 0.03), offsetRandom(0.04, 0.06));

					var shape = new THREE.Shape(pts);
					var geometry = new THREE.ShapeBufferGeometry( shape );
					var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: avg } ) );
					scene.add(mesh);
					mesh.position.z = zCount;
					zCount += 0.99;
					clearLine();

					numVertices = 0;
					scene.children.map(function(a) {
						if (a.id != squareBG.id) {
							numVertices += a.geometry.attributes.position.count;
						}
					});
					console.log(numVertices);
				}
			}

			function visualizePt(vec, c) {
				var geometry = new THREE.CircleGeometry( 10, 4 );
				var material = new THREE.MeshBasicMaterial({color:c});
				pt = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial({color:c}) );
				pt.position.x = vec.x;
				pt.position.y = vec.y;
				pt.position.z = MAX_ZDEPTH;

				scene.add( pt );
			}

			function visualizeLine(vec, c) {
				var lineGeo = new THREE.Geometry();
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));
				lineGeo.vertices.push(new THREE.Vector3(vec.x, vec.y, 0));

				visualizer = new THREE.Line( lineGeo, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
				visualizer.position.z = zCount;
				scene.add( visualizer );

				var circleGeo = new THREE.CircleGeometry( 20, 24 );
				var circleMat = new THREE.ShaderMaterial({
					vertexShader: document.getElementById("hueVisualizeVertex").textContent,
					fragmentShader: document.getElementById("hueVisualizeFragment").textContent,
					depthWrite: false,
					depthTest: false
				});
				hueVisualizer = new THREE.Mesh( circleGeo, circleMat );
				hueVisualizer.position.x = vec.x;
				hueVisualizer.position.y = vec.y;
				scene.add( hueVisualizer );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

			// Transform
			///////////////////////////////////////////////////////////////////
			function moveShape(shape, delta) {
				shape.position.x = startTransformPos.x + delta.x;
				shape.position.y = startTransformPos.y + delta.y;

			}
			// Events
			///////////////////////////////////////////////////////////////////
			// disable right click menu
			// document.oncontextmenu = function () {
			// 	return false;
			// };

			function saveCanvas() {
				var img = document.getElementById("canvas").toDataURL().replace("image/png", "image/octet-stream");
			  	document.getElementById("download").setAttribute("href", img);
			  	document.getElementById("download").setAttribute("download", "asdf.png");

			}

			function onKeyPress() {
				closeShape();
			}

			function startHueShift(event) {
				clearLine();
				try {
					hoverObj = checkIntersection(event);
					if (hoverObj && hoverObj.material.color) {
						hueShiftColor = hoverObj.material.color.clone();
						visualizeLine(currentPt(), new THREE.Color(0, 0, 0));
						event.preventDefault();
						event.stopPropagation();
					}
				} catch (err) {
					console.log(err);
				}
			}

			function onDocumentMouseDown(event) {
				if (MODE == 'draw') {
					debugEvent(event);
					if (event.type === "mousedown" || event.touches !== undefined) {

						var now = new Date().getTime();
						var since = now - latestTap;
						latestTap = new Date().getTime();

						if ((since < 200) && since > 0) {
							if (event.touches == undefined || event.touches.length == 1) {
								// double click > close shape, but only for mouse or single finger
								closeShape();
							}

						} else if (rightClick(event) || event.type == "touchstart" && event.touches.length == 2) {
							// right click or double finger drag > shift hue
							startHueShift(event);

						} else {
							// add point
							var vec = currentPt();
							prevPt = vec;
							addPoint(vec.x, vec.y);
						}
						event.preventDefault();
					}
				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected.id != squareBG.id) {
						currentObj = intersected;
						var vec = currentPt();
						startTransformPt = vec;
						startTransformPos = new THREE.Vector2();
						startTransformPos.copy(currentObj.position);
					}
				}
			}

			function onDocumentMouseMove(event) {
				if (MODE == 'draw') {
					debugEvent(event);

					if (event.type == "touchmove" && event.touches.length == 3) {
						prevPt = false;
						onDocumentMouseWheel(event);

					} else if ((rightClick(event) ||
							(event.type == "touchmove" && event.touches.length == 2))) {

						if (!hoverObj || !visualizer) {
							startHueShift();
						}

						clearLine();
						prevPt = false;
						var vec = currentPt();
						vec.z = 0;
						visualizer.geometry.vertices[1].x = vec.x;
						visualizer.geometry.vertices[1].y = vec.y;
						visualizer.geometry.verticesNeedUpdate = true;
						var diff = new THREE.Vector2(
							visualizer.geometry.vertices[1].x - visualizer.geometry.vertices[0].x,
							visualizer.geometry.vertices[1].y - visualizer.geometry.vertices[0].y,
						);
						var degrees = Math.atan2(diff.y, diff.x) / (2.0 * Math.PI);
						var amount = Math.min(diff.length() * HUE_SHIFT_SENSITIVITY, 1.0);

						hoverObj.material.color.set(hueShiftColor);

						// adjust hue in a copy of the color
						var offsetColor = new THREE.Color();
						hoverObj.material.color.getHSL(offsetColor);
						offsetColor.setHSL(degrees, 1.0, offsetColor.l);

						// mix offset color back into original color
						offsetColor.multiplyScalar(amount);
						hoverObj.material.color.multiplyScalar(1.0 - amount);
						hoverObj.material.color.add(offsetColor);
						event.preventDefault();

						// hoverObj.material.color.g = clamp(hoverObj.material.color.g + diff / 200.0, 0.0, 1.0);
					} else if ((event.type == "mousemove" || event.touches.length == 1)) {
						if (prevPt) {
							var vec = currentPt();
							if (sqdist(vec, prevPt) > PREV_DIST) {
								prevPt = vec;
								addPoint(vec.x, vec.y);
							}
						}
					}
				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected && intersected.id != squareBG.id) {
						document.body.style.cursor = 'pointer';
					} else {
						document.body.style.cursor = 'move';
					}
					if (currentObj && startTransformPt) {
						var vec = currentPt();
						vec.sub(startTransformPt)
						moveShape(currentObj, vec);
					}
				}
			}

			function onDocumentMouseUp(event) {
				debugEvent(event);

				// clear draw
				clearHueShift()

				// clear transform
				startTransformPt = false;
				currentObj = false;

				if (event.type == "mouseup" || event.touches.length == 0) {
					prevPt = false;
					latestDrag = false;
				}
			}

			function onDocumentMouseWheel(event) {
				if (MODE == 'draw') {
					clearHueShift();
					clearLine();

					var delta = mouseDelta();
					if (delta) {
						hoverObj = checkIntersection(event);
						if (hoverObj) {
							var hsl = new THREE.Color();
							hsl = hoverObj.material.color.getHSL(hsl);
							var deltaS = delta.x ? clamp(hsl.s + delta.x, 0, 1) : hsl.s;
							var deltaL = delta.y ? clamp(hsl.l + delta.y, 0, 1) : hsl.l;

							hoverObj.material.color.setHSL(hsl.h, deltaS, deltaL);
						}
					}
				} else if (MODE == 'transform') {
					var intersected = checkIntersection(event);
					if (intersected.id != squareBG.id) {
						var delta = mouseDelta();
						intersected.position.z = intersected.position.z + (delta.y > 0 ? -1 : 1);
						zCount = Math.max(intersected.position.z, zCount);
						normalizeZDepths();
					}
				}
				event.preventDefault();
			}

			function debugEvent(event) {
				// console.log(event.type);
				// console.log(event.touches.length);
			}

			function onDocumentResize() {
				var dim = Math.min(window.innerWidth, window.innerHeight) * 0.84;
				document.getElementById("canvas").style.width = dim + "px"
				document.getElementById("canvas").style.height = dim + "px"
				if (renderer != undefined) {
					renderer.setSize( dim, dim );
				}
			}

			// Utility
			///////////////////////////////////////////////////////////////////

			function clearHueShift() {
				if (visualizer) {
					scene.remove(visualizer);
					scene.remove(hueVisualizer);
					visualizer = false;
					hueVisualizer = false;
					return true;
				}
			}

			function clearLine() {
				if (currentLine) {
					scene.remove(currentLine);
					currentLine = false;
					pos_idx = 0;
					return true;
				}
			}

			function normalizeZDepths() {
				var sorted = scene.children.map(function(a) {
					return {'id': a.id, 'z': a.position.z }
				});
				sorted.sort((a, b) => a.z - b.z);
				var count = 0;
				sorted.map(function(a) {
					if (a.id != squareBG.id) {
						scene.getObjectById(a.id).position.z = count;
						count += 0.99;
					}
				});
			}

			function intersectPt(pt) {
				raycaster.setFromCamera( pt, camera );
				var intersects = raycaster.intersectObjects( [ scene ], true );
				// console.log(intersects.map(function(a) { console.log(a.object.position.z) }));
				if ( intersects.length > 0 ) {
					// assuming that ids are incremented with each new object
					intersects.sort((a, b) => b.object.position.z - a.object.position.z);
					// intersects.sort((a, b) => b.object.id - a.object.id);
					return intersects[ 0 ].object;
				}
			}

			function canvasPt(v) {
				var vec = new THREE.Vector3(); // create once and reuse
				var bb = document.getElementById("canvas").getBoundingClientRect();
				vec.set(((v.x) / bb.width) * 2,
					(-(v.y) / bb.height) * 2,
					0.5 );
				return vec;
			}

			function mouseDelta() {
				if (event.type == "touchmove") {
					// three finger drag
					var pt = mouseToCanvasPt();
					if (latestDrag) {
						var delta = {
							x: (pt.x - latestDrag.x),
							y: (pt.y - latestDrag.y)
						};
						latestDrag = pt;
						return delta;
					} else {
						latestDrag = pt;
						return false;
					}
				} else {
					// mouse
					return {
						x: 0.02 * clamp(-event.deltaX, -1, 1),
						y: 0.02 * clamp(-event.deltaY, -1, 1)
					};
				}
			}

			function mouseToCanvasPt() {
				var vec = new THREE.Vector3(); // create once and reuse

				if (event.touches != undefined) {
					// average all the touch coordinates
					var touches = Object.values(event.touches);
					vec.set(touches.reduce((a, b) => ({clientX: a.clientX + b.clientX})).clientX / touches.length,
						touches.reduce((a, b) => ({clientY: a.clientY + b.clientY})).clientY / touches.length,
						0.5);
					// vec.set(event.touches[0].clientX, event.touches[0].clientY, 0.5);
				} else {
					vec.set(event.clientX, event.clientY, 0.5);
				}

				var bb = document.getElementById("canvas").getBoundingClientRect();
				vec.set(((vec.x - bb.left) / bb.width) * 2 - 1,
					(-(vec.y - bb.top) / bb.height) * 2 + 1,
					0.5 );
				return vec;
			}

			function currentPt() {
				var vec = mouseToCanvasPt();
				vec.unproject( camera );
				vec.x = Math.max(-CANVAS_WIDTH, Math.min(vec.x, CANVAS_WIDTH));
				vec.y = Math.max(-CANVAS_HEIGHT, Math.min(vec.y, CANVAS_HEIGHT));
				return vec;
			}

			function sqdist(v1, v2) {
				return (v1.x - v2.x) ** 2 + (v1.x - v2.x) ** 2;
			}

			function clamp(v, a, b) {
				return Math.min(Math.max(v, a), b);
			}

			function rightClick(event) {
				return ("which" in event) ? event.which == 3 : event.button == 2;
			}
		</script>

	</body>
</html>
